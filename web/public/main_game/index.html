<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Ascension - Combat</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#4CAF50">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #222; 
    }
    canvas { 
      display: block; 
      margin: auto; 
      background: #000; 
    }
  </style>
  <!-- Inclusion du fichier de configuration -->
  <script src="/js/auth-utils.js"></script>
  <script src="/js/minigame-utils.js"></script>
  <script src="/configs/game-config.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // ===== Configuration initiale =====
    let levelId = 1; // Niveau par défaut
    let levelConfig = null;
    let playerStats = null;
    let gameStartTime = Date.now();
    let score = 0;
    let gameCompleted = false;
    let scoreSubmitted = false;
    
    // ===== Paramètres du terrain et des tuiles =====
    const gridWidth = 80;
    const gridHeight = 80;
    const tileWidth = 32;
    const tileHeight = 16;
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // ===== Chargement du fond =====
    const backgroundImage = new Image();
    backgroundImage.src = "school.png"; 
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    
    // ===== Définition des cartes de jeu (blockMap et heightMap) =====
    let blockMap = {};  // Sera initialisé avec les données du niveau
    let heightMap = {}; // Sera initialisé avec les données du niveau
    
    // ===== Définition de la fonction isBlocked =====
    function isBlocked(tileX, tileY) {
      if (tileX < 0 || tileX >= gridWidth || tileY < 0 || tileY >= gridHeight) return true;
      return blockMap[tileX + "," + tileY];
    }
    
    // ===== Gestion des entrées clavier =====
    let keys = {};
    window.addEventListener("keydown", e => { keys[e.key] = true; });
    window.addEventListener("keyup", e => { keys[e.key] = false; });
    
    // ===== Contrôle tactile pour le déplacement =====
    let touchInput = { x: 0, y: 0 };
    let touchStart = null;
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      touchStart = { x: touch.clientX, y: touch.clientY };
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      if(touchStart) {
        let touch = e.touches[0];
        let dx = touch.clientX - touchStart.x;
        let dy = touch.clientY - touchStart.y;
        let mag = Math.hypot(dx, dy);
        if(mag > 0) {
          touchInput.x = dx / mag;
          touchInput.y = dy / mag;
        } else {
          touchInput.x = 0;
          touchInput.y = 0;
        }
      }
    });
    canvas.addEventListener("touchend", function(e) {
      touchStart = null;
      touchInput.x = 0;
      touchInput.y = 0;
    });
    
    // ===== Conversion des coordonnées =====
    // De grille → monde (projection isométrique)
    function gridToWorld(x, y) {
      return {
        x: (x - y) * tileWidth / 2,
        y: (x + y) * tileHeight / 2
      };
    }
    // De monde → écran (avec l'offset de la caméra)
    function worldToScreen(worldX, worldY, cameraOffset) {
      return { x: worldX + cameraOffset.x, y: worldY + cameraOffset.y };
    }
    // De grille → écran
    function gridToScreen(x, y, cameraOffset) {
      const worldPos = gridToWorld(x, y);
      return worldToScreen(worldPos.x, worldPos.y, cameraOffset);
    }
    
    // ===== Caméra centrée sur le héros =====
    function getCameraOffset() {
      // Calcul classique pour centrer le héros
      const heroWorld = gridToWorld(hero.x, hero.y);
      let offset = {
        x: canvas.width / 2 - heroWorld.x - tileWidth / 2,
        y: canvas.height / 2 - heroWorld.y - tileHeight / 2
      };
      // Calculer la position de l'image de fond (centrée sur la grille)
      let gridCenter = gridToWorld(gridWidth / 2, gridHeight / 2);
      let bgX = gridCenter.x - backgroundImage.width / 2;
      let bgY = gridCenter.y - backgroundImage.height / 2;
      
      // Clamp de l'offset pour que le canvas reste dans l'image de fond
      offset.x = clamp(offset.x, canvas.width - backgroundImage.width - bgX, -bgX);
      offset.y = clamp(offset.y, canvas.height - backgroundImage.height - bgY, -bgY);
      
      return offset;
    }
    
    // ===== Définition du héros et des monstres =====
    // Positions en valeurs continues pour un déplacement fluide.
    const hero = {
      x: gridWidth / 2,
      y: gridHeight / 2,
      hp: 100,
      damage: 10,         // Valeur de base, sera augmentée par stats
      range: 10,
      attackSpeed: 1,     // 1 tir/s
      moveSpeed: 100,     // vitesse ajustée
      attackTimer: 0
    };
    let monsters = [];
    
    // ===== Initialisation du jeu =====
    async function initGame() {
      try {
        // 1. Vérifier l'authentification
        if (!checkAuth()) {
          window.location.href = '/';
          return;
        }
        
        // 2. Récupérer l'ID du niveau depuis l'URL
        const urlParams = new URLSearchParams(window.location.search);
        levelId = parseInt(urlParams.get('level') || '1');
        
        // 3. Charger les données du niveau
        await loadLevelData();
        
        // 4. Charger les statistiques du joueur
        await loadPlayerStats();
        
        // 5. Initialiser les monstres
        initBlockAndHeightMaps();
        spawnMonsters();
        
        // 6. Démarrer la boucle de jeu
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
        
      } catch (error) {
        console.error("Erreur d'initialisation:", error);
        alert("Erreur lors du chargement du jeu. Veuillez réessayer.");
        window.location.href = '/battle.html';
      }
    }
    
    async function loadLevelData() {
      try {
        // Charger la configuration du niveau depuis localStorage ou l'API
        let levelDataString = localStorage.getItem('currentLevelData');
        if (levelDataString) {
          levelConfig = JSON.parse(levelDataString);
        } else {
          // Si pas de données en localStorage, charger depuis l'API
          const response = await fetch(`/configs/levels.json`);
          if (!response.ok) {
            throw new Error('Erreur lors du chargement de la configuration des niveaux');
          }
          const config = await response.json();
          levelConfig = config.levels.find(level => level.id === levelId);
        }
        
        if (!levelConfig) {
          throw new Error(`Niveau ${levelId} non trouvé`);
        }
        
        console.log("Configuration du niveau chargée:", levelConfig);
      } catch (error) {
        console.error("Erreur lors du chargement du niveau:", error);
        // Configuration par défaut en cas d'erreur
        levelConfig = {
          id: levelId,
          name: "Niveau par défaut",
          monsters: [{
            type: "book",
            count: 10,
            health: 50,
            speed: 6,
            damage: 5
          }]
        };
      }
    }
    
    async function loadPlayerStats() {
      try {
        const stats = await fetchWithAuth('/api/player/stats');
        
        // Mettre à jour les statistiques du héros
        hero.damage = 10 + stats.attack; // Règle 1: damage = 10 + points en subcategory 1
        hero.range = 8 + stats.range * 0.5;
        hero.moveSpeed = 80 + stats.speed * 2;
        hero.attackSpeed = 1 + stats.precision * 0.1;
        hero.hp = 80 + stats.health * 2;
        
        console.log("Statistiques du joueur chargées:", stats);
        console.log("Statistiques du héros mises à jour:", hero);
        
        // Sauvegarder les stats pour utilisation ultérieure
        playerStats = stats;
        
      } catch (error) {
        console.error("Erreur lors du chargement des statistiques:", error);
        // Conserver les valeurs par défaut du héros
      }
    }
    
    function initBlockAndHeightMaps() {
      // Initialiser les cartes vides
      blockMap = {};
      heightMap = {};
      
      // Ajouter des obstacles basés sur la configuration du niveau
      if (levelConfig && levelConfig.obstacles) {
        levelConfig.obstacles.forEach(obstacle => {
          // Pour chaque obstacle, marquer les tuiles correspondantes comme bloquées
          for (let i = 0; i < obstacle.width; i++) {
            for (let j = 0; j < obstacle.height; j++) {
              const key = (obstacle.x + i) + "," + (obstacle.y + j);
              blockMap[key] = true;
              heightMap[key] = 2; // Hauteur arbitraire pour les obstacles
            }
          }
        });
      }
    }
    
    function spawnMonsters() {
      monsters = [];
      
      // Si pas de configuration de niveau, utiliser des valeurs par défaut
      if (!levelConfig || !levelConfig.monsters || levelConfig.monsters.length === 0) {
        // Spawn par défaut (10 monstres aléatoires)
        let count = 0;
        while (count < 10) {
          let mx = Math.random() * gridWidth;
          let my = Math.random() * gridHeight;
          if (Math.hypot(mx - hero.x, my - hero.y) < 5) continue;
          if (isBlocked(Math.floor(mx), Math.floor(my))) continue;
          monsters.push({
            x: mx,
            y: my,
            hp: 50,
            damage: 5,
            range: 5,
            attackSpeed: 1,
            moveSpeed: 6,
            attackTimer: 0,
            lastPathTime: 0,
            path: []
          });
          count++;
        }
        return;
      }
      
      // Utiliser la configuration du niveau pour spawn les monstres
      levelConfig.monsters.forEach(monsterType => {
        const count = monsterType.count || 5;
        const monsterData = {
          hp: monsterType.health || 50,
          damage: monsterType.damage || 5,
          range: monsterType.range / 10 || 5,
          attackSpeed: 1,
          moveSpeed: monsterType.speed / 10 || 6,
          type: monsterType.type || "book"
        };
        
        // Spawn le nombre requis de ce type de monstre
        for (let i = 0; i < count; i++) {
          // Trouver une position valide
          let mx, my;
          let validPosition = false;
          let attempts = 0;
          
          while (!validPosition && attempts < 100) {
            mx = Math.random() * gridWidth;
            my = Math.random() * gridHeight;
            
            // Vérifier si la position est valide (pas trop proche du héros, pas sur un obstacle)
            if (Math.hypot(mx - hero.x, my - hero.y) >= 10 && 
                !isBlocked(Math.floor(mx), Math.floor(my))) {
              validPosition = true;
            }
            
            attempts++;
          }
          
          if (validPosition) {
            monsters.push({
              x: mx,
              y: my,
              hp: monsterData.hp,
              damage: monsterData.damage,
              range: monsterData.range,
              attackSpeed: monsterData.attackSpeed,
              moveSpeed: monsterData.moveSpeed,
              type: monsterData.type,
              attackTimer: 0,
              lastPathTime: 0,
              path: []
            });
          }
        }
      });
      
      console.log(`${monsters.length} monstres générés pour le niveau ${levelId}`);
    }
    
    // ===== Amélioration du pathfinder (8 directions) =====
    function findPath(start, goal) {
      let openSet = [];
      let closedSet = new Set();
      function nodeKey(n) { return n.x + "," + n.y; }
      function heuristic(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
      openSet.push({ x: start.x, y: start.y, g: 0, h: heuristic(start, goal), f: heuristic(start, goal), cameFrom: null });
      let openMap = {};
      openMap[nodeKey(openSet[0])] = openSet[0];
      while (openSet.length > 0) {
        let currentIndex = 0;
        for (let i = 1; i < openSet.length; i++){
          if (openSet[i].f < openSet[currentIndex].f) currentIndex = i;
        }
        let current = openSet[currentIndex];
        if (current.x === goal.x && current.y === goal.y) {
          let path = [];
          while (current) {
            path.push({ x: current.x, y: current.y });
            current = current.cameFrom;
          }
          path.reverse();
          if (path.length > 0) path.shift();
          return path;
        }
        openSet.splice(currentIndex, 1);
        delete openMap[nodeKey(current)];
        closedSet.add(nodeKey(current));
        // Considérer 8 voisins
        let neighbors = [];
        for (let dx = -1; dx <= 1; dx++){
          for (let dy = -1; dy <= 1; dy++){
            if (dx === 0 && dy === 0) continue;
            neighbors.push({ x: current.x + dx, y: current.y + dy });
          }
        }
        for (let neighbor of neighbors) {
          let key = neighbor.x + "," + neighbor.y;
          if (neighbor.x < 0 || neighbor.x >= gridWidth || neighbor.y < 0 || neighbor.y >= gridHeight) continue;
          if (isBlocked(neighbor.x, neighbor.y)) continue;
          if (closedSet.has(key)) continue;
          let moveCost = (neighbor.x !== current.x && neighbor.y !== current.y) ? Math.SQRT2 : 1;
          let tentative_g = current.g + moveCost;
          let neighborNode = openMap[key];
          if (!neighborNode) {
            neighborNode = {
              x: neighbor.x,
              y: neighbor.y,
              g: tentative_g,
              h: heuristic(neighbor, goal),
              f: tentative_g + heuristic(neighbor, goal),
              cameFrom: current
            };
            openSet.push(neighborNode);
            openMap[key] = neighborNode;
          } else if (tentative_g < neighborNode.g) {
            neighborNode.g = tentative_g;
            neighborNode.f = tentative_g + neighborNode.h;
            neighborNode.cameFrom = current;
          }
        }
      }
      return []; // Aucun chemin trouvé
    }
    
    // ===== Système de projectiles =====
    let projectiles = [];
    const projectileSpeed = 10; // tuiles par seconde
    function spawnProjectile(source, target, owner) {
      let dx = target.x - source.x;
      let dy = target.y - source.y;
      let dist = Math.hypot(dx, dy);
      if (dist === 0) return;
      let vx = dx / dist;
      let vy = dy / dist;
      projectiles.push({
        x: source.x,
        y: source.y,
        vx: vx,
        vy: vy,
        damage: source.damage,
        owner: owner, // "hero" ou "monster"
        targetEntity: target.entity || null
      });
    }
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.x += p.vx * projectileSpeed * dt;
        p.y += p.vy * projectileSpeed * dt;
        if (p.x < 0 || p.x >= gridWidth || p.y < 0 || p.y >= gridHeight) {
          projectiles.splice(i, 1);
          continue;
        }
        let tileX = Math.floor(p.x);
        let tileY = Math.floor(p.y);
        if (isBlocked(tileX, tileY)) {
          projectiles.splice(i, 1);
          continue;
        }
        if (p.owner === "hero") {
          for (let j = 0; j < monsters.length; j++) {
            let m = monsters[j];
            if (Math.hypot(p.x - m.x, p.y - m.y) < 0.5) {
              m.hp -= p.damage;
              if (m.hp <= 0) {
                score += 10; // Gain de score à chaque monstre tué
              }
              projectiles.splice(i, 1);
              break;
            }
          }
        } else if (p.owner === "monster") {
          if (Math.hypot(p.x - hero.x, p.y - hero.y) < 0.5) {
            hero.hp -= p.damage;
            projectiles.splice(i, 1);
          }
        }
      }
    }
    function drawProjectiles(cameraOffset) {
      projectiles.forEach(p => {
        let screenPos = gridToScreen(p.x, p.y, cameraOffset);
        ctx.beginPath();
        ctx.arc(screenPos.x + tileWidth/2, screenPos.y + tileHeight/2, 3, 0, Math.PI * 2);
        ctx.fillStyle = "yellow";
        ctx.fill();
      });
    }
    
    // ===== Boucle principale =====
    let lastTime = performance.now();
    function gameLoop(timestamp) {
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      
      // Si jeu en cours, mettre à jour
      if (!gameCompleted && hero.hp > 0) {
        updateGame(dt);
      }
      
      // Toujours afficher
      drawGame();
      
      // Continuer la boucle si le jeu n'est pas terminé
      if (!scoreSubmitted) {
        requestAnimationFrame(gameLoop);
      }
    }
    
    // ===== Mise à jour du jeu =====
    function updateGame(dt) {
      // --- Traitement de l'input pour le déplacement ---
      let screenInput = { x: 0, y: 0 };
      if (keys["ArrowUp"]) { screenInput.y -= 1; }
      if (keys["ArrowDown"]) { screenInput.y += 1; }
      if (keys["ArrowLeft"]) { screenInput.x -= 1; }
      if (keys["ArrowRight"]) { screenInput.x += 1; }
      if (touchInput.x !== 0 || touchInput.y !== 0) {
        screenInput = { x: touchInput.x, y: touchInput.y };
      }
      let mag = Math.hypot(screenInput.x, screenInput.y);
      if (mag > 0) {
        screenInput.x /= mag;
        screenInput.y /= mag;
      }
      // Conversion du vecteur d'entrée de "screen space" en delta de grille
      let a = tileWidth / 2;  // 16
      let b = tileHeight / 2; // 8
      let gridDelta = { 
        x: (screenInput.x / a + screenInput.y / b) / 2,
        y: (screenInput.y / b - screenInput.x / a) / 2
      };
      if (mag > 0) {
        let proposedX = hero.x + gridDelta.x * hero.moveSpeed * dt;
        let proposedY = hero.y + gridDelta.y * hero.moveSpeed * dt;
        if (!isBlocked(Math.floor(proposedX), Math.floor(proposedY))) {
          hero.x = proposedX;
          hero.y = proposedY;
        } else {
          // Glissement : tester séparément X et Y
          if (!isBlocked(Math.floor(proposedX), Math.floor(hero.y))) {
            hero.x = proposedX;
          }
          if (!isBlocked(Math.floor(hero.x), Math.floor(proposedY))) {
            hero.y = proposedY;
          }
        }
      }
      
      // --- Attaque du héros ---
      hero.attackTimer += dt;
      if (hero.attackTimer >= 1 / hero.attackSpeed) {
        let target = null;
        let minDist = Infinity;
        monsters.forEach(m => {
          let d = Math.hypot(hero.x - m.x, hero.y - m.y);
          if (d <= hero.range && d < minDist) { minDist = d; target = m; }
        });
        if (target) {
          spawnProjectile(hero, { x: target.x, y: target.y, entity: target }, "hero");
          hero.attackTimer = 0;
        }
      }
      
      // --- Comportement des monstres avec pathfinding amélioré ---
      monsters.forEach(m => {
        let dx = hero.x - m.x;
        let dy = hero.y - m.y;
        let d = Math.hypot(dx, dy);
        if (d > m.range) {
          let currentTime = performance.now();
          if (!m.path || m.path.length === 0 || currentTime - m.lastPathTime > 500) {
            m.lastPathTime = currentTime;
            let start = { x: Math.floor(m.x), y: Math.floor(m.y) };
            let goal = { x: Math.floor(hero.x), y: Math.floor(hero.y) };
            m.path = findPath(start, goal);
          }
          if (m.path && m.path.length > 0) {
            let nextTile = m.path[0];
            let targetX = nextTile.x + 0.5;
            let targetY = nextTile.y + 0.5;
            let vx = targetX - m.x;
            let vy = targetY - m.y;
            let distToTile = Math.hypot(vx, vy);
            if (distToTile > 0.1) {
              vx /= distToTile;
              vy /= distToTile;
              let newX = m.x + vx * m.moveSpeed * dt;
              let newY = m.y + vy * m.moveSpeed * dt;
              if (!isBlocked(Math.floor(newX), Math.floor(newY))) {
                m.x = newX;
                m.y = newY;
              }
            }
            if (distToTile < 0.2) { m.path.shift(); }
          }
        }
        m.attackTimer += dt;
        if (d <= m.range && m.attackTimer >= 1 / m.attackSpeed) {
          spawnProjectile(m, { x: hero.x, y: hero.y, entity: hero }, "monster");
          m.attackTimer = 0;
        }
      });
      
      updateProjectiles(dt);
      monsters = monsters.filter(m => m.hp > 0);
      
      // Vérifier les conditions de fin de jeu
      if (hero.hp <= 0) {
        endGame(false);
      } else if (monsters.length === 0) {
        endGame(true);
      }
    }
    
    function endGame(success) {
      // Marquer le jeu comme terminé
      gameCompleted = true;
      
      // Calculer le temps écoulé et le score final
      const gameTimeSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
      score += Math.max(0, 300 - gameTimeSeconds); // Bonus de temps
      
      // Afficher l'écran de fin et soumettre les résultats
      if (!scoreSubmitted) {
        scoreSubmitted = true;
        
        // Envoyer les résultats au serveur
        submitResults(success, score, gameTimeSeconds);
        
        // Afficher l'écran de fin
        setTimeout(() => {
          showEndGameScreen(success);
        }, 500);
      }
    }
    
    function submitResults(success, finalScore, timeSpent) {
      // Récupérer l'ID du niveau depuis l'URL
      const urlParams = new URLSearchParams(window.location.search);
      const levelId = parseInt(urlParams.get('level') || '1');
      
      // Calculer le nombre d'étoiles (1 à 3)
      let starsCount = success ? Math.min(3, Math.max(1, Math.ceil(finalScore / 100))) : 0;
      
      // Données à envoyer
      const data = {
        levelId: levelId,
        success: success,
        score: finalScore,
        starsCount: starsCount,
        timeSpent: timeSpent
      };
      
      // Envoyer les résultats
      fetchWithAuth('/api/battle/complete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      })
      .then(response => {
        console.log('Résultats envoyés avec succès:', response);
      })
      .catch(error => {
        console.error('Erreur lors de l\'envoi des résultats:', error);
      });
    }
    
    function showEndGameScreen(success) {
      // Calcul des stars en fonction du score
      const starsCount = success ? Math.min(3, Math.max(1, Math.ceil(score / 100))) : 0;
      
      // Utiliser la fonction standard du panneau de fin de partie
      showEndgameScreen(
        score,                   // score obtenu
        300,                     // score maximum
        'strength',              // type de catégorie
        () => window.location.reload(),   // fonction de réinitialisation
        {
          minigameId: levelId,   // ID du mini-jeu/niveau
          difficultyLevel: 1,    // difficulté par défaut
          timeSpent: Math.floor((Date.now() - gameStartTime) / 1000)  // temps écoulé
        }
      );
    }
    
    function resetGame() {
      hero.x = gridWidth / 2;
      hero.y = gridHeight / 2;
      hero.hp = 100;
      hero.attackTimer = 0;
      spawnMonsters();
      projectiles = [];
      gameCompleted = false;
      scoreSubmitted = false;
      score = 0;
      gameStartTime = Date.now();
    }
    
    // ===== Affichage (draw) =====
    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let cameraOffset = getCameraOffset();
      
      // --- Dessiner le fond centré sur la grille ---
      let gridCenter = gridToWorld(gridWidth / 2, gridHeight / 2);
      let bgX = gridCenter.x - backgroundImage.width / 2;
      let bgY = gridCenter.y - backgroundImage.height / 2;
      ctx.drawImage(backgroundImage, bgX + cameraOffset.x, bgY + cameraOffset.y);
      
      // --- Dessiner les projectiles ---
      drawProjectiles(cameraOffset);
      
      // --- Dessiner le héros avec transparence si sur tuile élevée ---
      let heroTileKey = Math.floor(hero.x) + "," + Math.floor(hero.y);
      let heroOnElevated = (heightMap[heroTileKey] >= 2);
      let heroScreen = gridToScreen(hero.x, hero.y, cameraOffset);
      let heroCenterX = heroScreen.x + tileWidth/2;
      let heroCenterY = heroScreen.y + tileHeight/2;
      if (heroOnElevated) {
        ctx.save();
        ctx.globalAlpha = 0.25;
      }
      ctx.beginPath();
      ctx.arc(heroCenterX, heroCenterY, 10, 0, Math.PI * 2);
      ctx.fillStyle = "blue";
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(Math.floor(hero.hp), heroCenterX, heroCenterY - 12);
      if (heroOnElevated) { ctx.restore(); }
      
      // --- Dessiner les monstres avec transparence si sur tuile élevée ---
      monsters.forEach(m => {
        let mTileKey = Math.floor(m.x) + "," + Math.floor(m.y);
        let mOnElevated = (heightMap[mTileKey] >= 2);
        let mScreen = gridToScreen(m.x, m.y, cameraOffset);
        let mCenterX = mScreen.x + tileWidth/2;
        let mCenterY = mScreen.y + tileHeight/2;
        if (mOnElevated) { ctx.save(); ctx.globalAlpha = 0.25; }
        ctx.beginPath();
        ctx.arc(mCenterX, mCenterY, 10, 0, Math.PI * 2);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.fillStyle = "white";
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(Math.floor(m.hp), mCenterX, mCenterY - 12);
        if (mOnElevated) { ctx.restore(); }
      });
      
      // Afficher le score et autres informations
      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Score: ${score}`, 20, 30);
      ctx.fillText(`PV: ${Math.floor(hero.hp)} / ${hero.hp}`, 20, 60);
      ctx.fillText(`Monstres: ${monsters.length}`, 20, 90);
      
      // Afficher le chronomètre
      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      ctx.textAlign = 'right';
      ctx.fillText(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, canvas.width - 20, 30);
    }
    
    // ===== Mouseover pour mettre à jour hoveredTile (sans affichage) =====
    let hoveredTile = null;
    canvas.addEventListener("mousemove", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      let cameraOffset = getCameraOffset();
      const worldX = mouseX - cameraOffset.x;
      const worldY = mouseY - cameraOffset.y;
      const invX = worldX / (tileWidth / 2);
      const invY = worldY / (tileHeight / 2);
      let gridX = (invX + invY) / 2;
      let gridY = (invY - invX) / 2;
      hoveredTile = { x: Math.floor(gridX), y: Math.floor(gridY) };
    });
    canvas.addEventListener("mouseout", () => { hoveredTile = null; });
    
    // ===== Initialiser le jeu au chargement =====
    window.onload = initGame;
  </script>
</body>
</html>