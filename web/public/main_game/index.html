<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Ascension - Combat</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#4CAF50">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #222; 
    }
    canvas { 
      display: block; 
      margin: auto; 
      background: #000; 
    }
  </style>
  <!-- Inclusion du fichier de configuration -->
  <script src="/js/auth-utils.js"></script>
  <script src="/js/minigame-utils.js"></script>
  <script src="/configs/game-config.js"></script>
  <!-- Inclusion du fichier de configuration pour blockMap et heightMap -->
  <script src="config.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // ===== Configuration initiale =====
    let levelId = 1; // Niveau par défaut
    let levelConfig = null;
    let playerStats = null;
    let gameStartTime = Date.now();
    let score = 0;
    let gameCompleted = false;
    let scoreSubmitted = false;
    
    // ===== Paramètres du terrain et des tuiles =====
    const gridWidth = 80;
    const gridHeight = 80;
    const tileWidth = 32;
    const tileHeight = 16;
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const monsterImages = {}; 

    const heroImage = new Image();
    heroImage.src = "/assets/images/caracter/caracter_1.png";

    const projectileImage = new Image();
    projectileImage.src = "/assets/images/crayon.png";
    
    // ===== Chargement du fond =====
    const backgroundImage = new Image();
    backgroundImage.src = "school.png"; 
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    
    // ===== Définition de la fonction isBlocked =====
    function isBlocked(tileX, tileY) {
      if (tileX < 0 || tileX >= gridWidth || tileY < 0 || tileY >= gridHeight) return true;
      return blockMap[tileX + "," + tileY];
    }
    
    // ===== Gestion des entrées clavier =====
    let keys = {};
    window.addEventListener("keydown", e => { keys[e.key] = true; });
    window.addEventListener("keyup", e => { keys[e.key] = false; });
    
    // ===== Contrôle tactile pour le déplacement =====
    let touchInput = { x: 0, y: 0 };
    let touchStart = null;
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      touchStart = { x: touch.clientX, y: touch.clientY };
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      if(touchStart) {
        let touch = e.touches[0];
        let dx = touch.clientX - touchStart.x;
        let dy = touch.clientY - touchStart.y;
        let mag = Math.hypot(dx, dy);
        if(mag > 0) {
          touchInput.x = dx / mag;
          touchInput.y = dy / mag;
        } else {
          touchInput.x = 0;
          touchInput.y = 0;
        }
      }
    });
    canvas.addEventListener("touchend", function(e) {
      touchStart = null;
      touchInput.x = 0;
      touchInput.y = 0;
    });
    
    // ===== Conversion des coordonnées =====
    // De grille → monde (projection isométrique)
    function gridToWorld(x, y) {
      return {
        x: (x - y) * tileWidth / 2,
        y: (x + y) * tileHeight / 2
      };
    }
    // De monde → écran (avec l'offset de la caméra)
    function worldToScreen(worldX, worldY, cameraOffset) {
      return { x: worldX + cameraOffset.x, y: worldY + cameraOffset.y };
    }
    // De grille → écran
    function gridToScreen(x, y, cameraOffset) {
      const worldPos = gridToWorld(x, y);
      return worldToScreen(worldPos.x, worldPos.y, cameraOffset);
    }
    
    // ===== Caméra centrée sur le héros =====
    function getCameraOffset() {
      // Calcul classique pour centrer le héros
      const heroWorld = gridToWorld(hero.x, hero.y);
      let offset = {
        x: canvas.width / 2 - heroWorld.x - tileWidth / 2,
        y: canvas.height / 2 - heroWorld.y - tileHeight / 2
      };
      // Calculer la position de l'image de fond (centrée sur la grille)
      let gridCenter = gridToWorld(gridWidth / 2, gridHeight / 2);
      let bgX = gridCenter.x - backgroundImage.width / 2;
      let bgY = gridCenter.y - backgroundImage.height / 2;
      
      // Clamp de l'offset pour que le canvas reste dans l'image de fond
      offset.x = clamp(offset.x, canvas.width - backgroundImage.width - bgX, -bgX);
      offset.y = clamp(offset.y, canvas.height - backgroundImage.height - bgY, -bgY);
      
      return offset;
    }

    function preloadMonsterImages() {
      // Fonction pour charger une image avec gestion d'erreur
      function loadImage(design) {
          return new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                  monsterImages[design] = img;
                  resolve(true);
              };
              img.onerror = () => {
                  console.warn(`Image de monstre non trouvée: ${design}`);
                  resolve(false);
              };
              img.src = `/assets/images/monsters/${design}`;
          });
      }
      
      // Si la configuration du niveau est disponible, précharger les images
      if (levelConfig && levelConfig.monsters) {
          const uniqueDesigns = new Set();
          
          // Collecter tous les designs uniques
          levelConfig.monsters.forEach(monster => {
              if (monster.design) {
                  uniqueDesigns.add(monster.design);
              }
          });
          
          // Précharger toutes les images uniques
          const loadPromises = Array.from(uniqueDesigns).map(design => loadImage(design));
          return Promise.all(loadPromises);
      }
      
      return Promise.resolve();
    }
    
    // ===== Définition du héros et des monstres =====
    // Positions en valeurs continues pour un déplacement fluide.
    const hero = {
      x: gridWidth / 2,
      y: gridHeight / 2,
      hp: 100,                     // Points de vie de base
      maxHp: 100,                  // Maximum de points de vie
      damage: 10,                  // Dégâts de base
      range: 10,                   // Portée de base
      attackSpeed: 1,              // Vitesse d'attaque de base (1 tir/s)
      moveSpeed: 100,              // Vitesse de déplacement de base
      attackTimer: 0,              // Compteur pour la prochaine attaque
      
      // Sous-statistiques de Force
      attack: 0,                   // Bonus aux dégâts
      precision: 0,                // Précision des attaques
      critical: 0,                 // Chance de critique et dégâts critiques
      
      // Sous-statistiques d'Endurance
      health: 0,                   // Bonus aux points de vie
      armor: 0,                    // Réduction des dégâts
      dodge: 0,                    // Chance d'esquiver les attaques
      
      // Sous-statistiques de Récupération
      regen: 0,                    // Régénération de points de vie
      lifesteal: 0,                // Vol de vie sur les attaques
      
      // Sous-statistiques d'Agilité
      rangeBonus: 0,               // Bonus de portée
      speed: 0,                    // Bonus de vitesse de déplacement
      
      // Mécaniques dérivées
      critChance: 0,               // Chance de critique
      critDamage: 1.5,             // Multiplicateur de critique
      // ...etc.
    };
    let monsters = [];
    
    // ===== Initialisation du jeu =====
    async function initGame() {
      try {
          // 1. Vérifier l'authentification
          if (!checkAuth()) {
              window.location.href = '/';
              return;
          }
          
          // 2. Récupérer l'ID du niveau depuis l'URL
          const urlParams = new URLSearchParams(window.location.search);
          levelId = parseInt(urlParams.get('level') || '1');
          
          // 3. Charger les données du niveau
          await loadLevelData();
          
          // 4. Précharger les images des monstres
          await preloadMonsterImages();
          
          // 5. Charger les statistiques du joueur
          await loadPlayerStats();
          
          // 6. Initialiser les monstres
          initBlockAndHeightMaps();
          spawnMonsters();
          
          // 7. Démarrer la boucle de jeu
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
          
      } catch (error) {
          console.error("Erreur d'initialisation:", error);
          alert("Erreur lors du chargement du jeu. Veuillez réessayer.");
          window.location.href = '/battle.html';
      }
    }
    
    async function loadLevelData() {
      try {
          // Charger la configuration du niveau depuis localStorage ou l'API
          let levelDataString = localStorage.getItem('currentLevelData');
          if (levelDataString) {
              levelConfig = JSON.parse(levelDataString);
              console.log("Données du niveau chargées depuis localStorage:", levelConfig);
          } else {
              // Si pas de données en localStorage, charger depuis l'API
              console.log("Aucune donnée de niveau trouvée dans localStorage, tentative de chargement depuis l'API...");
              
              // Charger d'abord les informations de base du niveau
              const baseResponse = await fetch(`/configs/levels.json`);
              if (!baseResponse.ok) {
                  throw new Error('Erreur lors du chargement de la configuration des niveaux');
              }
              const baseConfig = await baseResponse.json();
              const baseLevelConfig = baseConfig.levels.find(level => level.id === levelId);
              
              if (!baseLevelConfig) {
                  throw new Error(`Niveau ${levelId} non trouvé dans la configuration de base`);
              }
              
              // Ensuite charger les détails du niveau (monstres) depuis l'API
              const detailsResponse = await fetchWithAuth(`/api/battle/level-details?id=${levelId}`);
              if (!detailsResponse) {
                  throw new Error(`Impossible de récupérer les détails du niveau ${levelId}`);
              }
              
              // Combiner les informations
              levelConfig = {
                  id: baseLevelConfig.id,
                  name: baseLevelConfig.name,
                  monsters: detailsResponse.monsters || []
              };
              
              console.log("Données du niveau chargées depuis l'API:", levelConfig);
          }
          
          if (!levelConfig) {
              throw new Error(`Niveau ${levelId} non trouvé`);
          }
          
          // Initialiser le titre du jeu avec le nom du niveau
          document.title = `Ascension - ${levelConfig.name || 'Niveau ' + levelId}`;
          
          return true;
      } catch (error) {
          console.error("Erreur lors du chargement du niveau:", error);
          // Configuration par défaut en cas d'erreur
          levelConfig = {
              id: levelId,
              name: "Niveau par défaut",
              monsters: [
                  {
                      name: "Livre Ensorcelé",
                      health: 50,
                      damage: 5,
                      range: 100,
                      speed: 80,
                      size: 30,
                      design: "book_default"
                  }
              ]
          };
          return false;
      }
    }
    
    async function loadPlayerStats() {
      try {
          const stats = await fetchWithAuth('/api/player/stats');
          
          // Récupérer toutes les sous-statistiques
          hero.attack = stats.attack || 0;
          hero.precision = stats.precision || 0;
          hero.critical = stats.critical || 0;
          hero.health = stats.health || 0;
          hero.armor = stats.armor || 0;
          hero.dodge = stats.dodge || 0;
          hero.regen = stats.regen || 0;
          hero.lifesteal = stats.lifesteal || 0;
          hero.rangeBonus = stats.range || 0;
          hero.speed = stats.speed || 0;
          
          // Appliquer les règles de calcul des statistiques principales
          // Force
          hero.damage = 10 + hero.attack;
          hero.attackSpeed = 1 + (hero.precision * 0.1);
          hero.critChance = hero.critical * 0.02; // 2% par point
          hero.critDamage = 1.5 + (hero.critical * 0.1);
          
          // Endurance
          hero.maxHp = 100 + (hero.health * 5);
          hero.hp = hero.maxHp; // Commencer avec HP max
          hero.damageReduction = hero.armor * 0.02; // 2% par point
          hero.dodgeChance = hero.dodge * 0.02; // 2% par point
          
          // Récupération
          hero.healthRegen = hero.regen * 0.1; // 0.1 HP/s par point
          hero.lifeStealPercent = hero.lifesteal * 0.03; // 3% par point
          
          // Agilité
          hero.range = 10 + (hero.rangeBonus * 0.5);
          hero.moveSpeed = 100 + (hero.speed * 2);
          
          console.log("Statistiques du joueur chargées:", stats);
          console.log("Statistiques du héros mises à jour:", hero);
          
          // Sauvegarder les stats pour utilisation ultérieure
          playerStats = stats;
          
      } catch (error) {
          console.error("Erreur lors du chargement des statistiques:", error);
          // Conserver les valeurs par défaut du héros
      }
    }
    
    function initBlockAndHeightMaps() {
      // Ajouter des obstacles basés sur la configuration du niveau
      if (levelConfig && levelConfig.obstacles) {
        levelConfig.obstacles.forEach(obstacle => {
          // Pour chaque obstacle, marquer les tuiles correspondantes comme bloquées
          for (let i = 0; i < obstacle.width; i++) {
            for (let j = 0; j < obstacle.height; j++) {
              const key = (obstacle.x + i) + "," + (obstacle.y + j);
              blockMap[key] = true;
              heightMap[key] = 2; // Hauteur arbitraire pour les obstacles
            }
          }
        });
      }
    }
    
    function spawnMonsters() {
      monsters = [];
      
      // Fonction pour vérifier si une position est valide pour un monstre
      function isValidMonsterPosition(x, y) {
          // Vérifier que la position n'est pas bloquée
          if (isBlocked(Math.floor(x), Math.floor(y))) {
              return false;
          }
          
          // Vérifier que le monstre n'est pas trop proche du héros
          if (Math.hypot(x - hero.x, y - hero.y) < 5) {
              return false;
          }
          
          // Vérifier qu'il existe un chemin vers le héros
          const path = findPath(
              { x: Math.floor(x), y: Math.floor(y) },
              { x: Math.floor(hero.x), y: Math.floor(hero.y) }
          );
          
          // Retourner vrai si le chemin existe et n'est pas vide
          return path && path.length > 0;
      }
      
      // Fonction pour trouver une position valide pour un monstre
      function findValidMonsterPosition() {
          let attempts = 0;
          const maxAttempts = 100;
          
          while (attempts < maxAttempts) {
              // Générer une position aléatoire
              const x = Math.random() * gridWidth;
              const y = Math.random() * gridHeight;
              
              // Vérifier la validité de la position
              if (isValidMonsterPosition(x, y)) {
                  return { x, y };
              }
              
              attempts++;
          }
          
          // Si aucune position valide n'est trouvée après plusieurs tentatives,
          // retourner une position près du centre (si possible)
          const centerX = gridWidth / 2;
          const centerY = gridHeight / 2;
          
          for (let dx = -10; dx <= 10; dx++) {
              for (let dy = -10; dy <= 10; dy++) {
                  const x = centerX + dx;
                  const y = centerY + dy;
                  if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight && 
                      isValidMonsterPosition(x, y)) {
                      return { x, y };
                  }
              }
          }
          
          // En dernier recours, retourner une position au hasard (même si invalide)
          return { x: gridWidth / 2, y: gridHeight / 2 };
      }
      
      // Si pas de configuration de niveau, utiliser des valeurs par défaut
      if (!levelConfig || !levelConfig.monsters || levelConfig.monsters.length === 0) {
          // Spawn par défaut (10 monstres aléatoires)
          for (let i = 0; i < 10; i++) {
              const position = findValidMonsterPosition();
              
              monsters.push({
                  x: position.x,
                  y: position.y,
                  hp: 50,
                  damage: 5,
                  range: 10,
                  attackSpeed: 1,
                  moveSpeed: 8,
                  size: 30,
                  attackTimer: 0,
                  lastPathTime: 0,
                  path: [],
                  name: "Monstre inconnu",
                  design: "default",
                  points: 10,
                  level : 1
              });
          }
          return;
      }
      
      // Utiliser la configuration du niveau pour spawn les monstres
      levelConfig.monsters.forEach(monster => {

        // S'assurer que le monstre a un niveau (utiliser 1 par défaut si non spécifié)
const monsterLevel = monster.monsterLevel || 1;

          // Vérifier si les coordonnées x et y sont spécifiées dans la config
          if (monster.x !== undefined && monster.y !== undefined) {
              // Utiliser les coordonnées spécifiées si elles sont valides
              if (isValidMonsterPosition(monster.x, monster.y)) {
                monsters.push({
                    x: monster.x,
                    y: monster.y,
                    hp: monster.health * (1+monsterLevel*0.2)|| 50,
                    damage: monster.damage* (1+monsterLevel*0.2) || 5,
                    range: monster.range || 5,
                    attackSpeed: monster.attackSpeed || 1,
                    moveSpeed: monster.speed|| 6,
                    size: monster.size || 30, 
                    attackTimer: 0,
                    lastPathTime: 0,
                    path: [],
                    name: monster.name || "Monstre inconnu",
                    design: monster.design || "default",
                    points: monster.points || 10
                });
              } else {
                  // Si les coordonnées spécifiées ne sont pas valides, trouver une position valide
                  const position = findValidMonsterPosition();
                  
                  monsters.push({
                      x: position.x,
                      y: position.y,
                      hp: monster.health * (1+monsterLevel*0.2)|| 50,
                      damage: monster.damage * (1+monsterLevel*0.2)|| 5,
                      range: monster.range || 5,
                      attackSpeed: monster.attackSpeed || 1,
                      moveSpeed: monster.speed || 6,
                      size: monster.size || 30, 
                      attackTimer: 0,
                      lastPathTime: 0,
                      path: [],
                      name: monster.name || "Monstre inconnu",
                      design: monster.design || "default",
                      points: monster.points || 10
                  });
              }
          } else {
              // Si x et y ne sont pas spécifiés, trouver une position valide
              const position = findValidMonsterPosition();
              
              monsters.push({
                  x: position.x,
                  y: position.y,
                  hp: monster.health* (1+monsterLevel*0.2) || 50,
                  damage: monster.damage * (1+monsterLevel*0.2)|| 5,
                  range: monster.range || 5,
                  attackSpeed: monster.attackSpeed || 1,
                  moveSpeed: monster.speed || 6,
                  size: monster.size || 30, 
                  attackTimer: 0,
                  lastPathTime: 0,
                  path: [],
                  name: monster.name || "Monstre inconnu",
                  design: monster.design || "default",
                  points: monster.points || 10
              });
          }
      });
      
      console.log(`${monsters.length} monstres générés pour le niveau ${levelId}`);
    }
    
    // ===== Amélioration du pathfinder (8 directions) =====
    function findPath(start, goal) {
      let openSet = [];
      let closedSet = new Set();
      function nodeKey(n) { return n.x + "," + n.y; }
      function heuristic(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
      openSet.push({ x: start.x, y: start.y, g: 0, h: heuristic(start, goal), f: heuristic(start, goal), cameFrom: null });
      let openMap = {};
      openMap[nodeKey(openSet[0])] = openSet[0];
      while (openSet.length > 0) {
        let currentIndex = 0;
        for (let i = 1; i < openSet.length; i++){
          if (openSet[i].f < openSet[currentIndex].f) currentIndex = i;
        }
        let current = openSet[currentIndex];
        if (current.x === goal.x && current.y === goal.y) {
          let path = [];
          while (current) {
            path.push({ x: current.x, y: current.y });
            current = current.cameFrom;
          }
          path.reverse();
          if (path.length > 0) path.shift();
          return path;
        }
        openSet.splice(currentIndex, 1);
        delete openMap[nodeKey(current)];
        closedSet.add(nodeKey(current));
        // Considérer 8 voisins
        let neighbors = [];
        for (let dx = -1; dx <= 1; dx++){
          for (let dy = -1; dy <= 1; dy++){
            if (dx === 0 && dy === 0) continue;
            neighbors.push({ x: current.x + dx, y: current.y + dy });
          }
        }
        for (let neighbor of neighbors) {
          let key = neighbor.x + "," + neighbor.y;
          if (neighbor.x < 0 || neighbor.x >= gridWidth || neighbor.y < 0 || neighbor.y >= gridHeight) continue;
          if (isBlocked(neighbor.x, neighbor.y)) continue;
          if (closedSet.has(key)) continue;
          let moveCost = (neighbor.x !== current.x && neighbor.y !== current.y) ? Math.SQRT2 : 1;
          let tentative_g = current.g + moveCost;
          let neighborNode = openMap[key];
          if (!neighborNode) {
            neighborNode = {
              x: neighbor.x,
              y: neighbor.y,
              g: tentative_g,
              h: heuristic(neighbor, goal),
              f: tentative_g + heuristic(neighbor, goal),
              cameFrom: current
            };
            openSet.push(neighborNode);
            openMap[key] = neighborNode;
          } else if (tentative_g < neighborNode.g) {
            neighborNode.g = tentative_g;
            neighborNode.f = tentative_g + neighborNode.h;
            neighborNode.cameFrom = current;
          }
        }
      }
      return []; // Aucun chemin trouvé
    }
    
    // ===== Système de projectiles =====
    let projectiles = [];
    const projectileSpeed = 10; // tuiles par seconde
    function spawnProjectile(source, target, owner) {
      let dx = target.x - source.x;
      let dy = target.y - source.y;
      let dist = Math.hypot(dx, dy);
      if (dist === 0) return;
      let vx = dx / dist;
      let vy = dy / dist;
      projectiles.push({
        x: source.x,
        y: source.y,
        vx: vx,
        vy: vy,
        damage: source.damage,
        owner: owner, // "hero" ou "monster"
        targetEntity: target.entity || null
      });
    }
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.x += p.vx * projectileSpeed * dt;
        p.y += p.vy * projectileSpeed * dt;
        if (p.x < 0 || p.x >= gridWidth || p.y < 0 || p.y >= gridHeight) {
          projectiles.splice(i, 1);
          continue;
        }
        let tileX = Math.floor(p.x);
        let tileY = Math.floor(p.y);
        if (isBlocked(tileX, tileY)) {
          projectiles.splice(i, 1);
          continue;
        }
        if (p.owner === "hero") {
          for (let j = 0; j < monsters.length; j++) {
            let m = monsters[j];
            if (Math.hypot(p.x - m.x, p.y - m.y) < 0.5) {
              m.hp -= p.damage;
              if (m.hp <= 0) {
                score += m.points; // Gain de score à chaque monstre tué
              }
              projectiles.splice(i, 1);
              break;
            }
          }
        } else if (p.owner === "monster") {
          if (Math.hypot(p.x - hero.x, p.y - hero.y) < 0.5) {
            hero.hp -= p.damage;
            projectiles.splice(i, 1);
          }
        }
      }
    }
    function drawProjectiles(cameraOffset) {
      projectiles.forEach(p => {
        let screenPos = gridToScreen(p.x, p.y, cameraOffset);
        let centerX = screenPos.x + tileWidth/2;
        let centerY = screenPos.y + tileHeight/2;
        
        if (p.owner === "hero") {
          // Pour les projectiles du héros, utiliser l'image du crayon
          
          // Calculer l'angle de rotation
          // Référence : angle 0 correspond à (vx=1, vy=0) soit un tir vers la droite
          const angle = Math.atan2(p.vy, p.vx);
          
          // Ajouter un ajustement de -45 degrés (-π/4 radians) pour corriger l'orientation
          const adjustedAngle = angle + Math.PI / 4;
          
          // Taille du projectile
          const projectileWidth = 24;
          const projectileHeight = 8;
          
          // Sauvegarder le contexte pour la rotation
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(adjustedAngle);
          
          // Dessiner l'image du projectile
          ctx.drawImage(
            projectileImage,
            -projectileWidth / 2,
            -projectileHeight / 2,
            projectileWidth,
            projectileHeight
          );
          
          // Restaurer le contexte
          ctx.restore();
        } else {
          // Pour les projectiles des monstres, conserver le dessin simple
          ctx.beginPath();
          ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
          ctx.fillStyle = "yellow";
          ctx.fill();
        }
      });
    }
    // ===== Boucle principale =====
    let lastTime = performance.now();
    function gameLoop(timestamp) {
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      
      // Si jeu en cours, mettre à jour
      if (!gameCompleted && hero.hp > 0) {
        updateGame(dt);
      }
      
      // Toujours afficher
      drawGame();
      
      // Continuer la boucle si le jeu n'est pas terminé
      if (!scoreSubmitted) {
        requestAnimationFrame(gameLoop);
      }
    }
    
    // ===== Mise à jour du jeu =====
    function updateGame(dt) {
      // --- Traitement de l'input pour le déplacement ---
      let screenInput = { x: 0, y: 0 };
      if (keys["ArrowUp"]) { screenInput.y -= 1; }
      if (keys["ArrowDown"]) { screenInput.y += 1; }
      if (keys["ArrowLeft"]) { screenInput.x -= 1; }
      if (keys["ArrowRight"]) { screenInput.x += 1; }
      if (touchInput.x !== 0 || touchInput.y !== 0) {
        screenInput = { x: touchInput.x, y: touchInput.y };
      }
      let mag = Math.hypot(screenInput.x, screenInput.y);
      if (mag > 0) {
        screenInput.x /= mag;
        screenInput.y /= mag;
      }
      // Conversion du vecteur d'entrée de "screen space" en delta de grille
      let a = tileWidth / 2;  // 16
      let b = tileHeight / 2; // 8
      let gridDelta = { 
        x: (screenInput.x / a + screenInput.y / b) / 2,
        y: (screenInput.y / b - screenInput.x / a) / 2
      };
      if (mag > 0) {
        let proposedX = hero.x + gridDelta.x * hero.moveSpeed * dt;
        let proposedY = hero.y + gridDelta.y * hero.moveSpeed * dt;
        if (!isBlocked(Math.floor(proposedX), Math.floor(proposedY))) {
          hero.x = proposedX;
          hero.y = proposedY;
        } else {
          // Glissement : tester séparément X et Y
          if (!isBlocked(Math.floor(proposedX), Math.floor(hero.y))) {
            hero.x = proposedX;
          }
          if (!isBlocked(Math.floor(hero.x), Math.floor(proposedY))) {
            hero.y = proposedY;
          }
        }
      }
      
      // --- Attaque du héros ---
      hero.attackTimer += dt;
      if (hero.attackTimer >= 1 / hero.attackSpeed) {
        let target = null;
        let minDist = Infinity;
        monsters.forEach(m => {
          let d = Math.hypot(hero.x - m.x, hero.y - m.y);
          if (d <= hero.range && d < minDist) { minDist = d; target = m; }
        });
        if (target) {
          spawnProjectile(hero, { x: target.x, y: target.y, entity: target }, "hero");
          hero.attackTimer = 0;
        }
      }
      
      // --- Comportement des monstres avec pathfinding amélioré ---
      monsters.forEach(m => {
        let dx = hero.x - m.x;
        let dy = hero.y - m.y;
        let d = Math.hypot(dx, dy);
        if (d > m.range) {
          let currentTime = performance.now();
          if (!m.path || m.path.length === 0 || currentTime - m.lastPathTime > 500) {
            m.lastPathTime = currentTime;
            let start = { x: Math.floor(m.x), y: Math.floor(m.y) };
            let goal = { x: Math.floor(hero.x), y: Math.floor(hero.y) };
            m.path = findPath(start, goal);
          }
          if (m.path && m.path.length > 0) {
            let nextTile = m.path[0];
            let targetX = nextTile.x + 0.5;
            let targetY = nextTile.y + 0.5;
            let vx = targetX - m.x;
            let vy = targetY - m.y;
            let distToTile = Math.hypot(vx, vy);
            if (distToTile > 0.1) {
              vx /= distToTile;
              vy /= distToTile;
              let newX = m.x + vx * m.moveSpeed * dt;
              let newY = m.y + vy * m.moveSpeed * dt;
              if (!isBlocked(Math.floor(newX), Math.floor(newY))) {
                m.x = newX;
                m.y = newY;
              }
            }
            if (distToTile < 0.2) { m.path.shift(); }
          }
        }
        m.attackTimer += dt;
        if (d <= m.range && m.attackTimer >= 1 / m.attackSpeed) {
          spawnProjectile(m, { x: hero.x, y: hero.y, entity: hero }, "monster");
          m.attackTimer = 0;
        }
      });
      
      updateProjectiles(dt);
      monsters = monsters.filter(m => m.hp > 0);
      
      // Vérifier les conditions de fin de jeu
      if (hero.hp <= 0) {
        endGame(false);
      } else if (monsters.length === 0) {
        endGame(true);
      }
    }
    
    function endGame(success) {
  // Marquer le jeu comme terminé
  gameCompleted = true;
  
  // Calculer le temps écoulé et le score final
  const gameTimeSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
  
  // Afficher l'écran de fin et soumettre les résultats
  if (!scoreSubmitted) {
    scoreSubmitted = true;
    
    // Envoyer les résultats au serveur et afficher l'écran de fin
    submitResults(success, score, gameTimeSeconds)
      .then(result => {
        showBattleEndScreen(success, result.nextLevelUnlocked);
      });
  }
}
    
function submitResults(success, finalScore, timeSpent) {
  // Récupérer l'ID du niveau depuis l'URL
  const urlParams = new URLSearchParams(window.location.search);
  const levelId = parseInt(urlParams.get('level') || '1');
  
  // Calculer le score maximum possible
  let maxPossibleScore = 0;
  if (levelConfig && levelConfig.monsters) {
    levelConfig.monsters.forEach(monster => {
      maxPossibleScore += monster.points || 10;
    });
  }
  if (maxPossibleScore <= 0) {
    maxPossibleScore = 100 * 10;
  }

  console.log('score : ', finalScore, ' sur total de : '  , maxPossibleScore);

  
  // Calculer les étoiles en fonction du pourcentage (comme dans showBattleEndScreen)
  const percentage = (finalScore / maxPossibleScore) * 100;
  let starsCount = 0;
  
  if (success) {
    if (percentage >= 95) {
      starsCount = 3;
    } else if (percentage >= 66) {
      starsCount = 2;
    } else if (percentage >= 30) {
      starsCount = 1;
    }
  }
  
  // Données à envoyer
  const data = {
    levelId: levelId,
    success: success,
    score: finalScore,
    starsCount: starsCount,
    timeSpent: timeSpent
  };
  
  // Envoyer les résultats et retourner une promesse
  return fetchWithAuth('/api/battle/complete', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data)
  })
  .then(response => {
    console.log('Résultats envoyés avec succès:', response);
    return {
      success: response.success,
      nextLevelUnlocked: response.nextLevelUnlocked || false
    };
  })
  .catch(error => {
    console.error('Erreur lors de l\'envoi des résultats:', error);
    return {
      success: false,
      nextLevelUnlocked: false
    };
  });
} 

function showBattleEndScreen(success, nextLevelUnlocked) {
  // Calculer le score maximum possible (somme des points de tous les monstres)
  let maxPossibleScore = 0;
  if (levelConfig && levelConfig.monsters) {
    levelConfig.monsters.forEach(monster => {
      maxPossibleScore += monster.points || 10;
    });
  }
  
  // Si aucun monstre ou pas de config, utiliser une valeur par défaut
  if (maxPossibleScore <= 0) {
    maxPossibleScore = 100 * 10; // 10 monstres à 100 points par défaut
  }
  
  // Calcul des stars en fonction du pourcentage de réussite
  const percentage = (score / maxPossibleScore) * 100;
  let starsCount = 0;
  
  if (success) {
    if (percentage >= 95) {
      starsCount = 3;
    } else if (percentage >= 66) {
      starsCount = 2;
    } else if (percentage >= 30) {
      starsCount = 1;
    }
  }
  
  // Créer le conteneur modal s'il n'existe pas déjà
  let modalContainer = document.getElementById('battle-endgame-modal-container');
  if (modalContainer) {
    modalContainer.remove();
  }
  
  modalContainer = document.createElement('div');
  modalContainer.id = 'battle-endgame-modal-container';
  
  // Récupérer l'ID du niveau
  const urlParams = new URLSearchParams(window.location.search);
  const currentLevelId = parseInt(urlParams.get('level') || '1');
  
  // Définir le style du modal en fonction du succès ou de l'échec
  const titleText = success ? "Victoire !" : "Défaite";
  const titleColor = success ? "#ffd700" : "#e74c3c"; // Or pour victoire, rouge pour défaite
  const titleShadow = success ? "0 0 15px rgba(255, 215, 0, 0.8)" : "0 0 15px rgba(231, 76, 60, 0.8)";
  const messageText = nextLevelUnlocked ? "Niveau suivant débloqué !" : "Vous pouvez réessayer";
  
  // Générer les étoiles avec des images
  const starsHTML = Array(3).fill().map((_, i) => {
    const isActive = i < starsCount;
    return `<img 
      src="/assets/images/star.png" 
      alt="Étoile" 
      style="
        width: 48px; 
        height: 48px; 
        filter: ${isActive ? 'brightness(1) drop-shadow(0 0 5px rgba(255, 215, 0, 0.8))' : 'brightness(0.3) grayscale(1)'};
        transition: transform 0.3s ease;
        ${isActive ? 'animation: star-pop 0.5s ease-out;' : ''}
      "
    >`;
  }).join('');
  
  // Créer des fonctions globales temporaires pour les gestionnaires d'événements
  window.battleEndNext = function() {
    if (nextLevelUnlocked) {
      window.location.href = `/battle.html?level=${currentLevelId + 1}`;
    } else {
      window.location.reload();
    }
  };
  
  window.battleEndQuit = function() {
    window.location.href = '/battle.html';
  };
  
  // Choisir le bouton gauche selon si le niveau suivant est débloqué
  const leftButtonImg = nextLevelUnlocked ? "/assets/images/next.webp" : "/assets/images/replay.webp";
  const leftButtonAlt = nextLevelUnlocked ? "Niveau suivant" : "Rejouer";
  
  // Définir le HTML du modal
  modalContainer.innerHTML = `
    <style>
      #battle-endgame-modal-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: 'Comic Neue', 'Nunito', 'Arial', sans-serif;
      }
      
      @keyframes star-pop {
        0% { transform: scale(0.5); opacity: 0.5; }
        50% { transform: scale(1.2); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
      }
      
      .frame-container {
        background-image: url('/assets/images/endgame_frame.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        width: 90%;
        max-width: 500px;
        aspect-ratio: 1 / 1.2;
        padding: 30px;
        text-align: center;
        position: relative;
      }
      
      .content-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 25%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-top: 5%;
      }
      
      .buttons-container {
        position: absolute;
        bottom: 13%;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 30px;
        z-index: 10000;
      }
      
      .button-image {
        width: 90px;
        height: auto;
        cursor: pointer;
        transition: transform 0.3s ease;
      }
      
      .button-image:hover {
        transform: scale(1.1);
      }
      
      .victory-title {
        font-size: 1.8rem; 
        color: ${titleColor}; 
        text-shadow: ${titleShadow}; 
        margin-bottom: 10px;
        animation: ${success ? 'pulse 1.5s infinite' : 'none'};
      }
      
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
      }
    </style>
    
    <div class="frame-container">
      <!-- Conteneur pour centrer le contenu principal -->
      <div class="content-container">
        <div style="width: 80%;">
          <h2 class="victory-title">
            ${titleText}
          </h2>
          
          <div style="display: flex; justify-content: center; gap: 15px; margin: 10px 0;">
            ${starsHTML}
          </div>
          
          <div style="font-size: 1.3rem; color: #ffffff; margin: 15px 0;">
            Ton score est de <span style="font-weight: bold;">${score}</span> / ${maxPossibleScore}
          </div>
          
          <div style="font-size: 1.1rem; color: ${nextLevelUnlocked ? '#4ae07c' : '#ffffff'}; margin: 10px 0; font-weight: ${nextLevelUnlocked ? 'bold' : 'normal'}">
            ${messageText}
          </div>
        </div>
      </div>
      
      <!-- Boutons de fin fixés en bas -->
      <div class="buttons-container">
        <img src="${leftButtonImg}" alt="${leftButtonAlt}" class="button-image" onclick="window.battleEndNext()">
        <img src="/assets/images/quit.png" alt="Quitter" class="button-image" onclick="window.battleEndQuit()">
      </div>
    </div>
  `;
  
  // Ajouter le modal au document
  document.body.appendChild(modalContainer);
  
  // Essayer de charger la police Comic Neue
  try {
    const fontLink = document.createElement('link');
    fontLink.href = 'https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap';
    fontLink.rel = 'stylesheet';
    document.head.appendChild(fontLink);
  } catch (error) {
    console.warn("Impossible de charger la police:", error);
  }
}
    
    function resetGame() {
      hero.x = gridWidth / 2;
      hero.y = gridHeight / 2;
      hero.hp = 100;
      hero.attackTimer = 0;
      spawnMonsters();
      projectiles = [];
      gameCompleted = false;
      scoreSubmitted = false;
      score = 0;
      gameStartTime = Date.now();
    }
    
    // ===== Affichage (draw) =====
    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let cameraOffset = getCameraOffset();
      
      // --- Dessiner le fond centré sur la grille ---
      let gridCenter = gridToWorld(gridWidth / 2, gridHeight / 2);
      let bgX = gridCenter.x - backgroundImage.width / 2;
      let bgY = gridCenter.y - backgroundImage.height / 2;
      ctx.drawImage(backgroundImage, bgX + cameraOffset.x, bgY + cameraOffset.y);
      
      // --- Dessiner les projectiles ---
      drawProjectiles(cameraOffset);
      
      // --- Dessiner le héros avec transparence si sur tuile élevée ---
      let heroTileKey = Math.floor(hero.x) + "," + Math.floor(hero.y);
      let heroOnElevated = (heightMap[heroTileKey] >= 2);
      let heroScreen = gridToScreen(hero.x, hero.y, cameraOffset);
      let heroCenterX = heroScreen.x + tileWidth/2;
      let heroCenterY = heroScreen.y + tileHeight/2;
      
      if (heroOnElevated) {
        ctx.save();
        ctx.globalAlpha = 0.25;
      }
      
      // Dessiner l'image du héros au lieu d'un cercle
      const heroHeight = 40; // Hauteur fixe
      const heroWidth = (heroImage.width / heroImage.height) * heroHeight;
      ctx.drawImage(
        heroImage, 
        heroCenterX - heroWidth/2, 
        heroCenterY - heroHeight/2, 
        heroWidth, 
        heroHeight
      );
      
      // Afficher la vie du héros au-dessus
      ctx.fillStyle = "white";
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(Math.floor(hero.hp), heroCenterX, heroCenterY - 25);
      
      if (heroOnElevated) { ctx.restore(); }
      
      // --- Dessiner les monstres avec transparence si sur tuile élevée ---
      monsters.forEach(m => {
        let mTileKey = Math.floor(m.x) + "," + Math.floor(m.y);
        let mOnElevated = (heightMap[mTileKey] >= 2);
        let mScreen = gridToScreen(m.x, m.y, cameraOffset);
        let mCenterX = mScreen.x + tileWidth/2;
        let mCenterY = mScreen.y + tileHeight/2;
        
        if (mOnElevated) { ctx.save(); ctx.globalAlpha = 0.25; }
        
        // Utiliser directement la taille du monstre depuis les données
        let monsterSize = m.size || 30;
        
        // Vérifier si l'image du monstre est disponible
        if (m.design && monsterImages[m.design]) {
            // Dessiner l'image du monstre
            const img = monsterImages[m.design];
            const monsterHeight = m.size || 30;
            const monsterWidth = (img.width / img.height) * monsterHeight;

            // Dessiner avec le centre de l'image à la position du monstre
            ctx.drawImage(
                img, 
                mCenterX - monsterWidth / 2, 
                mCenterY - monsterHeight / 2,
                monsterWidth,
                monsterHeight
            );
        } else {
            // Solution de repli : dessiner un cercle rouge
            ctx.beginPath();
            ctx.arc(mCenterX, mCenterY, monsterSize / 3, 0, Math.PI * 2);
            ctx.fillStyle = "red";
            ctx.fill();
        }
        
        // Ajouter les points de vie au-dessus du monstre
        ctx.fillStyle = "white";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        
        // Dessiner le texte avec contour pour meilleure visibilité
        ctx.strokeText(Math.floor(m.hp), mCenterX, mCenterY - monsterSize / 2 - 5);
        ctx.fillText(Math.floor(m.hp), mCenterX, mCenterY - monsterSize / 2 - 5);
        
        if (mOnElevated) { ctx.restore(); }
      });
      
      // Afficher le score et autres informations
      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Score: ${score}`, 20, 30);
      ctx.fillText(`PV: ${Math.floor(hero.hp)} / ${hero.maxHp}`, 20, 60);
      ctx.fillText(`Monstres: ${monsters.length}`, 20, 90);
      
      // Afficher le chronomètre
      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      ctx.textAlign = 'right';
      ctx.fillText(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, canvas.width - 20, 30);
    }
    // ===== Mouseover pour mettre à jour hoveredTile (sans affichage) =====
    let hoveredTile = null;
    canvas.addEventListener("mousemove", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      let cameraOffset = getCameraOffset();
      const worldX = mouseX - cameraOffset.x;
      const worldY = mouseY - cameraOffset.y;
      const invX = worldX / (tileWidth / 2);
      const invY = worldY / (tileHeight / 2);
      let gridX = (invX + invY) / 2;
      let gridY = (invY - invX) / 2;
      hoveredTile = { x: Math.floor(gridX), y: Math.floor(gridY) };
    });
    canvas.addEventListener("mouseout", () => { hoveredTile = null; });
    
    // ===== Initialiser le jeu au chargement =====
    window.onload = initGame;
  </script>
</body>
</html>