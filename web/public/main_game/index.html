<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Ascension - Combat</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#4CAF50">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #222; 
    }
    canvas { 
      display: block; 
      margin: auto; 
      background: #000; 
    }
  </style>
  <!-- Inclusion du fichier de configuration -->
  <script src="/js/auth-utils.js"></script>
  <script src="/js/minigame-utils.js"></script>
  <script src="/configs/game-config.js"></script>
  <!-- Inclusion du fichier de configuration pour blockMap et heightMap -->
  <script src="config.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // ===== Configuration initiale =====
    let levelId = 1; // Niveau par défaut
    let levelConfig = null;
    let playerStats = null;
    let gameStartTime = Date.now();
    let score = 0;
    let gameCompleted = false;
    let scoreSubmitted = false;
    
    // ===== Paramètres du terrain et des tuiles =====
    const gridWidth = 80;
    const gridHeight = 80;
    const tileWidth = 32;
    const tileHeight = 16;
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const monsterImages = {}; 
    
    // ===== Chargement du fond =====
    const backgroundImage = new Image();
    backgroundImage.src = "school.png"; 
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    
    // ===== Définition de la fonction isBlocked =====
    function isBlocked(tileX, tileY) {
      if (tileX < 0 || tileX >= gridWidth || tileY < 0 || tileY >= gridHeight) return true;
      return blockMap[tileX + "," + tileY];
    }
    
    // ===== Gestion des entrées clavier =====
    let keys = {};
    window.addEventListener("keydown", e => { keys[e.key] = true; });
    window.addEventListener("keyup", e => { keys[e.key] = false; });
    
    // ===== Contrôle tactile pour le déplacement =====
    let touchInput = { x: 0, y: 0 };
    let touchStart = null;
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      touchStart = { x: touch.clientX, y: touch.clientY };
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      if(touchStart) {
        let touch = e.touches[0];
        let dx = touch.clientX - touchStart.x;
        let dy = touch.clientY - touchStart.y;
        let mag = Math.hypot(dx, dy);
        if(mag > 0) {
          touchInput.x = dx / mag;
          touchInput.y = dy / mag;
        } else {
          touchInput.x = 0;
          touchInput.y = 0;
        }
      }
    });
    canvas.addEventListener("touchend", function(e) {
      touchStart = null;
      touchInput.x = 0;
      touchInput.y = 0;
    });
    
    // ===== Conversion des coordonnées =====
    // De grille → monde (projection isométrique)
    function gridToWorld(x, y) {
      return {
        x: (x - y) * tileWidth / 2,
        y: (x + y) * tileHeight / 2
      };
    }
    // De monde → écran (avec l'offset de la caméra)
    function worldToScreen(worldX, worldY, cameraOffset) {
      return { x: worldX + cameraOffset.x, y: worldY + cameraOffset.y };
    }
    // De grille → écran
    function gridToScreen(x, y, cameraOffset) {
      const worldPos = gridToWorld(x, y);
      return worldToScreen(worldPos.x, worldPos.y, cameraOffset);
    }
    
    // ===== Caméra centrée sur le héros =====
    function getCameraOffset() {
      // Calcul classique pour centrer le héros
      const heroWorld = gridToWorld(hero.x, hero.y);
      let offset = {
        x: canvas.width / 2 - heroWorld.x - tileWidth / 2,
        y: canvas.height / 2 - heroWorld.y - tileHeight / 2
      };
      // Calculer la position de l'image de fond (centrée sur la grille)
      let gridCenter = gridToWorld(gridWidth / 2, gridHeight / 2);
      let bgX = gridCenter.x - backgroundImage.width / 2;
      let bgY = gridCenter.y - backgroundImage.height / 2;
      
      // Clamp de l'offset pour que le canvas reste dans l'image de fond
      offset.x = clamp(offset.x, canvas.width - backgroundImage.width - bgX, -bgX);
      offset.y = clamp(offset.y, canvas.height - backgroundImage.height - bgY, -bgY);
      
      return offset;
    }

    function preloadMonsterImages() {
    // Fonction pour charger une image avec gestion d'erreur
    function loadImage(design) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                monsterImages[design] = img;
                resolve(true);
            };
            img.onerror = () => {
                console.warn(`Image de monstre non trouvée: ${design}`);
                resolve(false);
            };
            img.src = `/assets/images/monsters/${design}`;
        });
    }
    
    // Si la configuration du niveau est disponible, précharger les images
    if (levelConfig && levelConfig.monsters) {
        const uniqueDesigns = new Set();
        
        // Collecter tous les designs uniques
        levelConfig.monsters.forEach(monster => {
            if (monster.design) {
                uniqueDesigns.add(monster.design);
            }
        });
        
        // Ajouter le design du boss s'il existe
        if (levelConfig.boss && levelConfig.boss.design) {
            uniqueDesigns.add(levelConfig.boss.design);
        }
        
        // Précharger toutes les images uniques
        const loadPromises = Array.from(uniqueDesigns).map(design => loadImage(design));
        return Promise.all(loadPromises);
    }
    
    return Promise.resolve();
}
    
    // ===== Définition du héros et des monstres =====
    // Positions en valeurs continues pour un déplacement fluide.
    const hero = {
    x: gridWidth / 2,
    y: gridHeight / 2,
    hp: 100,                     // Points de vie de base
    maxHp: 100,                  // Maximum de points de vie
    damage: 10,                  // Dégâts de base
    range: 10,                   // Portée de base
    attackSpeed: 1,              // Vitesse d'attaque de base (1 tir/s)
    moveSpeed: 100,              // Vitesse de déplacement de base
    attackTimer: 0,              // Compteur pour la prochaine attaque
    
    // Sous-statistiques de Force
    attack: 0,                   // Bonus aux dégâts
    precision: 0,                // Précision des attaques
    critical: 0,                 // Chance de critique et dégâts critiques
    
    // Sous-statistiques d'Endurance
    health: 0,                   // Bonus aux points de vie
    armor: 0,                    // Réduction des dégâts
    dodge: 0,                    // Chance d'esquiver les attaques
    
    // Sous-statistiques de Récupération
    regen: 0,                    // Régénération de points de vie
    lifesteal: 0,                // Vol de vie sur les attaques
    
    // Sous-statistiques d'Agilité
    rangeBonus: 0,               // Bonus de portée
    speed: 0,                    // Bonus de vitesse de déplacement
    
    // Mécaniques dérivées
    critChance: 0,               // Chance de critique
    critDamage: 1.5,             // Multiplicateur de critique
    // ...etc.
};
    let monsters = [];
    
    // ===== Initialisation du jeu =====
    async function initGame() {
    try {
        // 1. Vérifier l'authentification
        if (!checkAuth()) {
            window.location.href = '/';
            return;
        }
        
        // 2. Récupérer l'ID du niveau depuis l'URL
        const urlParams = new URLSearchParams(window.location.search);
        levelId = parseInt(urlParams.get('level') || '1');
        
        // 3. Charger les données du niveau
        await loadLevelData();
        
        // 4. Précharger les images des monstres
        await preloadMonsterImages();
        
        // 5. Charger les statistiques du joueur
        await loadPlayerStats();
        
        // 6. Initialiser les monstres
        initBlockAndHeightMaps();
        spawnMonsters();
        
        // 7. Démarrer la boucle de jeu
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
        
    } catch (error) {
        console.error("Erreur d'initialisation:", error);
        alert("Erreur lors du chargement du jeu. Veuillez réessayer.");
        window.location.href = '/battle.html';
    }
}
    
    async function loadLevelData() {
    try {
        // Charger la configuration du niveau depuis localStorage ou l'API
        let levelDataString = localStorage.getItem('currentLevelData');
        if (levelDataString) {
            levelConfig = JSON.parse(levelDataString);
            console.log("Données du niveau chargées depuis localStorage:", levelConfig);
        } else {
            // Si pas de données en localStorage, charger depuis l'API
            console.log("Aucune donnée de niveau trouvée dans localStorage, tentative de chargement depuis l'API...");
            
            // Charger d'abord les informations de base du niveau
            const baseResponse = await fetch(`/configs/levels.json`);
            if (!baseResponse.ok) {
                throw new Error('Erreur lors du chargement de la configuration des niveaux');
            }
            const baseConfig = await baseResponse.json();
            const baseLevelConfig = baseConfig.levels.find(level => level.id === levelId);
            
            if (!baseLevelConfig) {
                throw new Error(`Niveau ${levelId} non trouvé dans la configuration de base`);
            }
            
            // Ensuite charger les détails du niveau (monstres, boss) depuis l'API
            const detailsResponse = await fetchWithAuth(`/api/battle/level-details?id=${levelId}`);
            if (!detailsResponse) {
                throw new Error(`Impossible de récupérer les détails du niveau ${levelId}`);
            }
            
            // Combiner les informations
            levelConfig = {
                id: baseLevelConfig.id,
                name: baseLevelConfig.name,
                monsters: detailsResponse.monsters || [],
                boss: detailsResponse.boss || null
            };
            
            console.log("Données du niveau chargées depuis l'API:", levelConfig);
        }
        
        if (!levelConfig) {
            throw new Error(`Niveau ${levelId} non trouvé`);
        }
        
        // Initialiser le titre du jeu avec le nom du niveau
        document.title = `Ascension - ${levelConfig.name || 'Niveau ' + levelId}`;
        
        return true;
    } catch (error) {
        console.error("Erreur lors du chargement du niveau:", error);
        // Configuration par défaut en cas d'erreur
        levelConfig = {
            id: levelId,
            name: "Niveau par défaut",
            monsters: [
                {
                    name: "Livre Ensorcelé",
                    health: 50,
                    damage: 5,
                    range: 100,
                    speed: 80,
                    size: 30,
                    design: "book_default"
                }
            ]
        };
        return false;
    }
}
    
async function loadPlayerStats() {
    try {
        const stats = await fetchWithAuth('/api/player/stats');
        
        // Récupérer toutes les sous-statistiques
        hero.attack = stats.attack || 0;
        hero.precision = stats.precision || 0;
        hero.critical = stats.critical || 0;
        hero.health = stats.health || 0;
        hero.armor = stats.armor || 0;
        hero.dodge = stats.dodge || 0;
        hero.regen = stats.regen || 0;
        hero.lifesteal = stats.lifesteal || 0;
        hero.rangeBonus = stats.range || 0;
        hero.speed = stats.speed || 0;
        
        // Appliquer les règles de calcul des statistiques principales
        // Force
        hero.damage = 10 + hero.attack;
        hero.attackSpeed = 1 + (hero.precision * 0.1);
        hero.critChance = hero.critical * 0.02; // 2% par point
        hero.critDamage = 1.5 + (hero.critical * 0.1);
        
        // Endurance
        hero.maxHp = 100 + (hero.health * 5);
        hero.hp = hero.maxHp; // Commencer avec HP max
        hero.damageReduction = hero.armor * 0.02; // 2% par point
        hero.dodgeChance = hero.dodge * 0.02; // 2% par point
        
        // Récupération
        hero.healthRegen = hero.regen * 0.1; // 0.1 HP/s par point
        hero.lifeStealPercent = hero.lifesteal * 0.03; // 3% par point
        
        // Agilité
        hero.range = 10 + (hero.rangeBonus * 0.5);
        hero.moveSpeed = 100 + (hero.speed * 2);
        
        console.log("Statistiques du joueur chargées:", stats);
        console.log("Statistiques du héros mises à jour:", hero);
        
        // Sauvegarder les stats pour utilisation ultérieure
        playerStats = stats;
        
    } catch (error) {
        console.error("Erreur lors du chargement des statistiques:", error);
        // Conserver les valeurs par défaut du héros
    }
}
    
    function initBlockAndHeightMaps() {
      
      // Ajouter des obstacles basés sur la configuration du niveau
      if (levelConfig && levelConfig.obstacles) {
        levelConfig.obstacles.forEach(obstacle => {
          // Pour chaque obstacle, marquer les tuiles correspondantes comme bloquées
          for (let i = 0; i < obstacle.width; i++) {
            for (let j = 0; j < obstacle.height; j++) {
              const key = (obstacle.x + i) + "," + (obstacle.y + j);
              blockMap[key] = true;
              heightMap[key] = 2; // Hauteur arbitraire pour les obstacles
            }
          }
        });
      }
    }
    
    function spawnMonsters() {
    monsters = [];
    
    // Si pas de configuration de niveau, utiliser des valeurs par défaut
    if (!levelConfig || !levelConfig.monsters || levelConfig.monsters.length === 0) {
        // Spawn par défaut (10 monstres aléatoires)
        let count = 0;
        while (count < 10) {
            let mx = Math.random() * gridWidth;
            let my = Math.random() * gridHeight;
            if (Math.hypot(mx - hero.x, my - hero.y) < 5) continue;
            if (isBlocked(Math.floor(mx), Math.floor(my))) continue;
            monsters.push({
                x: mx,
                y: my,
                hp: 50,
                damage: 5,
                range: 5,
                attackSpeed: 1,
                moveSpeed: 6,
                attackTimer: 0,
                lastPathTime: 0,
                path: [],
                name: "Monstre inconnu",
                design: "default"
            });
            count++;
        }
        return;
    }
    
    // Utiliser la configuration du niveau pour spawn les monstres
    levelConfig.monsters.forEach(monster => {
        // Trouver une position valide pour le monstre
        let mx, my;
        let validPosition = false;
        let attempts = 0;
        
        while (!validPosition && attempts < 100) {
            mx = Math.random() * gridWidth;
            my = Math.random() * gridHeight;
            
            // Vérifier si la position est valide (pas trop proche du héros, pas sur un obstacle)
            if (Math.hypot(mx - hero.x, my - hero.y) >= 10 && 
                !isBlocked(Math.floor(mx), Math.floor(my))) {
                validPosition = true;
            }
            
            attempts++;
        }
        
        if (validPosition) {
            monsters.push({
                x: mx,
                y: my,
                hp: monster.health || 50,  // Utiliser les données du monstre avec fallback
                damage: monster.damage || 5,
                range: monster.range / 10 || 5,  // Ajuster la portée pour le gameplay
                attackSpeed: monster.attackSpeed || 1,
                moveSpeed: monster.speed / 10 || 6,  // Ajuster la vitesse pour le gameplay
                attackTimer: 0,
                lastPathTime: 0,
                path: [],
                name: monster.name || "Monstre inconnu",
                design: monster.design || "default"
            });
        }
    });
    
    // Ajouter le boss si présent
    if (levelConfig.boss) {
        let boss = levelConfig.boss;
        
        // Positionner le boss dans une zone spécifique ou aléatoire
        let bossX = gridWidth / 2;
        let bossY = gridHeight / 2;
        
        // S'assurer que la position n'est pas bloquée
        let validPosition = false;
        let attempts = 0;
        while (!validPosition && attempts < 100) {
            if (!isBlocked(Math.floor(bossX), Math.floor(bossY))) {
                validPosition = true;
            } else {
                bossX = Math.random() * gridWidth;
                bossY = Math.random() * gridHeight;
                attempts++;
            }
        }
        
        if (validPosition) {
            monsters.push({
                x: bossX,
                y: bossY,
                hp: boss.health || 100,
                damage: boss.damage || 10,
                range: boss.range / 10 || 8,
                attackSpeed: boss.attackSpeed || 0.8,
                moveSpeed: boss.speed / 10 || 5,
                attackTimer: 0,
                lastPathTime: 0,
                path: [],
                name: boss.name || "Boss",
                design: boss.design || "boss_default",
                isBoss: true  // Marquer comme boss pour un traitement spécial
            });
        }
    }
    
    console.log(`${monsters.length} monstres générés pour le niveau ${levelId}`);
}
    
    // ===== Amélioration du pathfinder (8 directions) =====
    function findPath(start, goal) {
      let openSet = [];
      let closedSet = new Set();
      function nodeKey(n) { return n.x + "," + n.y; }
      function heuristic(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
      openSet.push({ x: start.x, y: start.y, g: 0, h: heuristic(start, goal), f: heuristic(start, goal), cameFrom: null });
      let openMap = {};
      openMap[nodeKey(openSet[0])] = openSet[0];
      while (openSet.length > 0) {
        let currentIndex = 0;
        for (let i = 1; i < openSet.length; i++){
          if (openSet[i].f < openSet[currentIndex].f) currentIndex = i;
        }
        let current = openSet[currentIndex];
        if (current.x === goal.x && current.y === goal.y) {
          let path = [];
          while (current) {
            path.push({ x: current.x, y: current.y });
            current = current.cameFrom;
          }
          path.reverse();
          if (path.length > 0) path.shift();
          return path;
        }
        openSet.splice(currentIndex, 1);
        delete openMap[nodeKey(current)];
        closedSet.add(nodeKey(current));
        // Considérer 8 voisins
        let neighbors = [];
        for (let dx = -1; dx <= 1; dx++){
          for (let dy = -1; dy <= 1; dy++){
            if (dx === 0 && dy === 0) continue;
            neighbors.push({ x: current.x + dx, y: current.y + dy });
          }
        }
        for (let neighbor of neighbors) {
          let key = neighbor.x + "," + neighbor.y;
          if (neighbor.x < 0 || neighbor.x >= gridWidth || neighbor.y < 0 || neighbor.y >= gridHeight) continue;
          if (isBlocked(neighbor.x, neighbor.y)) continue;
          if (closedSet.has(key)) continue;
          let moveCost = (neighbor.x !== current.x && neighbor.y !== current.y) ? Math.SQRT2 : 1;
          let tentative_g = current.g + moveCost;
          let neighborNode = openMap[key];
          if (!neighborNode) {
            neighborNode = {
              x: neighbor.x,
              y: neighbor.y,
              g: tentative_g,
              h: heuristic(neighbor, goal),
              f: tentative_g + heuristic(neighbor, goal),
              cameFrom: current
            };
            openSet.push(neighborNode);
            openMap[key] = neighborNode;
          } else if (tentative_g < neighborNode.g) {
            neighborNode.g = tentative_g;
            neighborNode.f = tentative_g + neighborNode.h;
            neighborNode.cameFrom = current;
          }
        }
      }
      return []; // Aucun chemin trouvé
    }
    
    // ===== Système de projectiles =====
    let projectiles = [];
    const projectileSpeed = 10; // tuiles par seconde
    function spawnProjectile(source, target, owner) {
      let dx = target.x - source.x;
      let dy = target.y - source.y;
      let dist = Math.hypot(dx, dy);
      if (dist === 0) return;
      let vx = dx / dist;
      let vy = dy / dist;
      projectiles.push({
        x: source.x,
        y: source.y,
        vx: vx,
        vy: vy,
        damage: source.damage,
        owner: owner, // "hero" ou "monster"
        targetEntity: target.entity || null
      });
    }
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.x += p.vx * projectileSpeed * dt;
        p.y += p.vy * projectileSpeed * dt;
        if (p.x < 0 || p.x >= gridWidth || p.y < 0 || p.y >= gridHeight) {
          projectiles.splice(i, 1);
          continue;
        }
        let tileX = Math.floor(p.x);
        let tileY = Math.floor(p.y);
        if (isBlocked(tileX, tileY)) {
          projectiles.splice(i, 1);
          continue;
        }
        if (p.owner === "hero") {
          for (let j = 0; j < monsters.length; j++) {
            let m = monsters[j];
            if (Math.hypot(p.x - m.x, p.y - m.y) < 0.5) {
              m.hp -= p.damage;
              if (m.hp <= 0) {
                score += 10; // Gain de score à chaque monstre tué
              }
              projectiles.splice(i, 1);
              break;
            }
          }
        } else if (p.owner === "monster") {
          if (Math.hypot(p.x - hero.x, p.y - hero.y) < 0.5) {
            hero.hp -= p.damage;
            projectiles.splice(i, 1);
          }
        }
      }
    }
    function drawProjectiles(cameraOffset) {
      projectiles.forEach(p => {
        let screenPos = gridToScreen(p.x, p.y, cameraOffset);
        ctx.beginPath();
        ctx.arc(screenPos.x + tileWidth/2, screenPos.y + tileHeight/2, 3, 0, Math.PI * 2);
        ctx.fillStyle = "yellow";
        ctx.fill();
      });
    }
    
    // ===== Boucle principale =====
    let lastTime = performance.now();
    function gameLoop(timestamp) {
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      
      // Si jeu en cours, mettre à jour
      if (!gameCompleted && hero.hp > 0) {
        updateGame(dt);
      }
      
      // Toujours afficher
      drawGame();
      
      // Continuer la boucle si le jeu n'est pas terminé
      if (!scoreSubmitted) {
        requestAnimationFrame(gameLoop);
      }
    }
    
    // ===== Mise à jour du jeu =====
    function updateGame(dt) {
      // --- Traitement de l'input pour le déplacement ---
      let screenInput = { x: 0, y: 0 };
      if (keys["ArrowUp"]) { screenInput.y -= 1; }
      if (keys["ArrowDown"]) { screenInput.y += 1; }
      if (keys["ArrowLeft"]) { screenInput.x -= 1; }
      if (keys["ArrowRight"]) { screenInput.x += 1; }
      if (touchInput.x !== 0 || touchInput.y !== 0) {
        screenInput = { x: touchInput.x, y: touchInput.y };
      }
      let mag = Math.hypot(screenInput.x, screenInput.y);
      if (mag > 0) {
        screenInput.x /= mag;
        screenInput.y /= mag;
      }
      // Conversion du vecteur d'entrée de "screen space" en delta de grille
      let a = tileWidth / 2;  // 16
      let b = tileHeight / 2; // 8
      let gridDelta = { 
        x: (screenInput.x / a + screenInput.y / b) / 2,
        y: (screenInput.y / b - screenInput.x / a) / 2
      };
      if (mag > 0) {
        let proposedX = hero.x + gridDelta.x * hero.moveSpeed * dt;
        let proposedY = hero.y + gridDelta.y * hero.moveSpeed * dt;
        if (!isBlocked(Math.floor(proposedX), Math.floor(proposedY))) {
          hero.x = proposedX;
          hero.y = proposedY;
        } else {
          // Glissement : tester séparément X et Y
          if (!isBlocked(Math.floor(proposedX), Math.floor(hero.y))) {
            hero.x = proposedX;
          }
          if (!isBlocked(Math.floor(hero.x), Math.floor(proposedY))) {
            hero.y = proposedY;
          }
        }
      }
      
      // --- Attaque du héros ---
      hero.attackTimer += dt;
      if (hero.attackTimer >= 1 / hero.attackSpeed) {
        let target = null;
        let minDist = Infinity;
        monsters.forEach(m => {
          let d = Math.hypot(hero.x - m.x, hero.y - m.y);
          if (d <= hero.range && d < minDist) { minDist = d; target = m; }
        });
        if (target) {
          spawnProjectile(hero, { x: target.x, y: target.y, entity: target }, "hero");
          hero.attackTimer = 0;
        }
      }
      
      // --- Comportement des monstres avec pathfinding amélioré ---
      monsters.forEach(m => {
        let dx = hero.x - m.x;
        let dy = hero.y - m.y;
        let d = Math.hypot(dx, dy);
        if (d > m.range) {
          let currentTime = performance.now();
          if (!m.path || m.path.length === 0 || currentTime - m.lastPathTime > 500) {
            m.lastPathTime = currentTime;
            let start = { x: Math.floor(m.x), y: Math.floor(m.y) };
            let goal = { x: Math.floor(hero.x), y: Math.floor(hero.y) };
            m.path = findPath(start, goal);
          }
          if (m.path && m.path.length > 0) {
            let nextTile = m.path[0];
            let targetX = nextTile.x + 0.5;
            let targetY = nextTile.y + 0.5;
            let vx = targetX - m.x;
            let vy = targetY - m.y;
            let distToTile = Math.hypot(vx, vy);
            if (distToTile > 0.1) {
              vx /= distToTile;
              vy /= distToTile;
              let newX = m.x + vx * m.moveSpeed * dt;
              let newY = m.y + vy * m.moveSpeed * dt;
              if (!isBlocked(Math.floor(newX), Math.floor(newY))) {
                m.x = newX;
                m.y = newY;
              }
            }
            if (distToTile < 0.2) { m.path.shift(); }
          }
        }
        m.attackTimer += dt;
        if (d <= m.range && m.attackTimer >= 1 / m.attackSpeed) {
          spawnProjectile(m, { x: hero.x, y: hero.y, entity: hero }, "monster");
          m.attackTimer = 0;
        }
      });
      
      updateProjectiles(dt);
      monsters = monsters.filter(m => m.hp > 0);
      
      // Vérifier les conditions de fin de jeu
      if (hero.hp <= 0) {
        endGame(false);
      } else if (monsters.length === 0) {
        endGame(true);
      }
    }
    
    function endGame(success) {
      // Marquer le jeu comme terminé
      gameCompleted = true;
      
      // Calculer le temps écoulé et le score final
      const gameTimeSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
      score += Math.max(0, 300 - gameTimeSeconds); // Bonus de temps
      
      // Afficher l'écran de fin et soumettre les résultats
      if (!scoreSubmitted) {
        scoreSubmitted = true;
        
        // Envoyer les résultats au serveur
        submitResults(success, score, gameTimeSeconds);
        
        // Afficher l'écran de fin
        setTimeout(() => {
          showEndGameScreen(success);
        }, 500);
      }
    }
    
    function submitResults(success, finalScore, timeSpent) {
      // Récupérer l'ID du niveau depuis l'URL
      const urlParams = new URLSearchParams(window.location.search);
      const levelId = parseInt(urlParams.get('level') || '1');
      
      // Calculer le nombre d'étoiles (1 à 3)
      let starsCount = success ? Math.min(3, Math.max(1, Math.ceil(finalScore / 100))) : 0;
      
      // Données à envoyer
      const data = {
        levelId: levelId,
        success: success,
        score: finalScore,
        starsCount: starsCount,
        timeSpent: timeSpent
      };
      
      // Envoyer les résultats
      fetchWithAuth('/api/battle/complete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      })
      .then(response => {
        console.log('Résultats envoyés avec succès:', response);
      })
      .catch(error => {
        console.error('Erreur lors de l\'envoi des résultats:', error);
      });
    }
    
    function showEndGameScreen(success) {
      // Calcul des stars en fonction du score
      const starsCount = success ? Math.min(3, Math.max(1, Math.ceil(score / 100))) : 0;
      
      // Utiliser la fonction standard du panneau de fin de partie
      showEndgameScreen(
        score,                   // score obtenu
        300,                     // score maximum
        'strength',              // type de catégorie
        () => window.location.reload(),   // fonction de réinitialisation
        {
          minigameId: levelId,   // ID du mini-jeu/niveau
          difficultyLevel: 1,    // difficulté par défaut
          timeSpent: Math.floor((Date.now() - gameStartTime) / 1000)  // temps écoulé
        }
      );
    }
    
    function resetGame() {
      hero.x = gridWidth / 2;
      hero.y = gridHeight / 2;
      hero.hp = 100;
      hero.attackTimer = 0;
      spawnMonsters();
      projectiles = [];
      gameCompleted = false;
      scoreSubmitted = false;
      score = 0;
      gameStartTime = Date.now();
    }
    
    // ===== Affichage (draw) =====
    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let cameraOffset = getCameraOffset();
      
      // --- Dessiner le fond centré sur la grille ---
      let gridCenter = gridToWorld(gridWidth / 2, gridHeight / 2);
      let bgX = gridCenter.x - backgroundImage.width / 2;
      let bgY = gridCenter.y - backgroundImage.height / 2;
      ctx.drawImage(backgroundImage, bgX + cameraOffset.x, bgY + cameraOffset.y);
      
      // --- Dessiner les projectiles ---
      drawProjectiles(cameraOffset);
      
      // --- Dessiner le héros avec transparence si sur tuile élevée ---
      let heroTileKey = Math.floor(hero.x) + "," + Math.floor(hero.y);
      let heroOnElevated = (heightMap[heroTileKey] >= 2);
      let heroScreen = gridToScreen(hero.x, hero.y, cameraOffset);
      let heroCenterX = heroScreen.x + tileWidth/2;
      let heroCenterY = heroScreen.y + tileHeight/2;
      if (heroOnElevated) {
        ctx.save();
        ctx.globalAlpha = 0.25;
      }
      ctx.beginPath();
      ctx.arc(heroCenterX, heroCenterY, 10, 0, Math.PI * 2);
      ctx.fillStyle = "blue";
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(Math.floor(hero.hp), heroCenterX, heroCenterY - 12);
      if (heroOnElevated) { ctx.restore(); }
      
      // --- Dessiner les monstres avec transparence si sur tuile élevée ---
      monsters.forEach(m => {
    let mTileKey = Math.floor(m.x) + "," + Math.floor(m.y);
    let mOnElevated = (heightMap[mTileKey] >= 2);
    let mScreen = gridToScreen(m.x, m.y, cameraOffset);
    let mCenterX = mScreen.x + tileWidth/2;
    let mCenterY = mScreen.y + tileHeight/2;
    
    if (mOnElevated) { ctx.save(); ctx.globalAlpha = 0.25; }
    
    // Déterminer la taille du monstre
    let monsterSize = m.isBoss ? 40 : 30;
    if (m.size) {
        monsterSize = m.size;
    }
    
    // Vérifier si l'image du monstre est disponible
    if (m.design && monsterImages[m.design]) {
        // Dessiner l'image du monstre
        const img = monsterImages[m.design];
        const scaleFactor = monsterSize / Math.max(img.width, img.height);
        const width = img.width * scaleFactor;
        const height = img.height * scaleFactor;
        
        // Dessiner avec le centre de l'image à la position du monstre
        ctx.drawImage(
            img, 
            mCenterX - width / 2, 
            mCenterY - height / 2,
            width,
            height
        );
        
        // Pour les boss, ajouter une aura ou un effet spécial
        if (m.isBoss) {
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(mCenterX, mCenterY, monsterSize * 1.2, 0, Math.PI * 2);
            ctx.fillStyle = "#FFD700"; // Aura dorée pour les boss
            ctx.fill();
            ctx.restore();
        }
    } else {
        // Solution de repli : dessiner un cercle rouge
        ctx.beginPath();
        ctx.arc(mCenterX, mCenterY, monsterSize / 3, 0, Math.PI * 2);
        ctx.fillStyle = m.isBoss ? "#F39C12" : "red";
        ctx.fill();
        
        // Pour les boss, ajouter un contour
        if (m.isBoss) {
            ctx.strokeStyle = "#FFD700"; // Or
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
    
    // Ajouter les points de vie au-dessus du monstre
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.font = m.isBoss ? "bold 14px Arial" : "10px Arial";
    ctx.textAlign = "center";
    
    // Dessiner le texte avec contour pour meilleure visibilité
    ctx.strokeText(Math.floor(m.hp), mCenterX, mCenterY - monsterSize / 2 - 5);
    ctx.fillText(Math.floor(m.hp), mCenterX, mCenterY - monsterSize / 2 - 5);
    
    // Ajouter le nom du monstre en dessous pour les boss
    if (m.isBoss) {
        const bossName = m.name || "Boss";
        ctx.font = "bold 12px Arial";
        ctx.strokeText(bossName, mCenterX, mCenterY - monsterSize / 2 - 20);
        ctx.fillText(bossName, mCenterX, mCenterY - monsterSize / 2 - 20);
    }
    
    if (mOnElevated) { ctx.restore(); }
});
      
      // Afficher le score et autres informations
      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Score: ${score}`, 20, 30);
      ctx.fillText(`PV: ${Math.floor(hero.hp)} / ${hero.hp}`, 20, 60);
      ctx.fillText(`Monstres: ${monsters.length}`, 20, 90);
      
      // Afficher le chronomètre
      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      ctx.textAlign = 'right';
      ctx.fillText(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, canvas.width - 20, 30);
    }
    
    // ===== Mouseover pour mettre à jour hoveredTile (sans affichage) =====
    let hoveredTile = null;
    canvas.addEventListener("mousemove", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      let cameraOffset = getCameraOffset();
      const worldX = mouseX - cameraOffset.x;
      const worldY = mouseY - cameraOffset.y;
      const invX = worldX / (tileWidth / 2);
      const invY = worldY / (tileHeight / 2);
      let gridX = (invX + invY) / 2;
      let gridY = (invY - invX) / 2;
      hoveredTile = { x: Math.floor(gridX), y: Math.floor(gridY) };
    });
    canvas.addEventListener("mouseout", () => { hoveredTile = null; });
    
    // ===== Initialiser le jeu au chargement =====
    window.onload = initGame;
  </script>
</body>
</html>