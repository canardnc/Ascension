<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Isométrique</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background-color: #111; 
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script src="/js/auth-utils.js"></script>
    <script>
        // 1. Classe pour gérer le chargement et l'accès aux sprites
        class SpriteManager {
            constructor() {
                this.sprites = {}; // Pour stocker les images individuelles
                this.spritesheets = {}; // Pour stocker les feuilles de sprites
                this.loadedCount = 0;
                this.totalCount = 0;
            }
            
            // Charge une image individuelle
            loadSprite(name, url) {
                this.totalCount++;
                
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.sprites[name] = img;
                        this.loadedCount++;
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.error(`Erreur de chargement du sprite: ${url}`);
                        reject(new Error(`Impossible de charger le sprite: ${url}`));
                    };
                    img.src = url;
                });
            }
            
            // Charge plusieurs sprites
            loadSprites(spritesList) {
                const promises = [];
                
                for (const [name, url] of Object.entries(spritesList)) {
                    promises.push(this.loadSprite(name, url));
                }
                
                return Promise.all(promises);
            }
            
            // Récupérer un sprite par son nom
            getSprite(name) {
                return this.sprites[name];
            }
            
            // Dessine un frame spécifique d'une feuille de sprites
            drawSpriteFrame(ctx, sheetName, frameIndex, x, y, width, height) {
                const sheet = this.spritesheets[sheetName];
                if (!sheet) {
                    console.error(`Feuille de sprites non trouvée: ${sheetName}`);
                    return;
                }
                
                const framesPerRow = sheet.framesPerRow;
                const row = Math.floor(frameIndex / framesPerRow);
                const col = frameIndex % framesPerRow;
                
                ctx.drawImage(
                    sheet.image,
                    col * sheet.frameWidth,
                    row * sheet.frameHeight,
                    sheet.frameWidth,
                    sheet.frameHeight,
                    x - width/2,  // Centrer l'image
                    y - height/2, // Centrer l'image
                    width,
                    height
                );
            }
            
            // Obtenir le pourcentage de chargement
            getLoadingProgress() {
                if (this.totalCount === 0) return 100;
                return Math.floor((this.loadedCount / this.totalCount) * 100);
            }
        }

        // Fonctions de conversion entre coordonnées cartésiennes et isométriques
        function cartToIso(cartX, cartY) {
            const isoX = cartX - cartY;
            const isoY = (cartX + cartY) / 2;
            return { x: isoX, y: isoY };
        }

        function isoToCart(isoX, isoY) {
            const cartX = (2 * isoY + isoX) / 2;
            const cartY = (2 * isoY - isoX) / 2;
            return { x: cartX, y: cartY };
        }

        // 2. Classe pour les personnages animés (joueur ou monstres)
        class AnimatedCharacter {
            constructor(spriteManager, x, y, width, height) {
                this.spriteManager = spriteManager;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.health = 10;
                this.maxHealth = 10;
                
                // Animation
                this.direction = 'down'; // down, up, left, right
                this.frame = 0;
                this.frameCount = 6; // Nombre de frames par animation
                this.frameDuration = 8; // Durée de chaque frame
                this.frameTimer = 0;
                this.moving = false;
                
                // Pour le joueur, mapping des directions aux indices de ligne dans la spritesheet
                this.directionMap = {
                    'down': 0,
                    'left': 1,
                    'right': 2,
                    'up': 3
                };
                
                // Pour les monstres/slimes, l'animation est différente
                this.monsterDirectionMap = {
                    'down': 6,
                    'left': 7,
                    'right': 9,
                    'up': 8
                };
                
                // Type de monstre (pour les ennemis)
                this.monsterType = 'slime';
                this.speed = 100;
                
                // Attributs pour les attaques
                this.attackRange = 200;
                this.lastAttackTime = 0;
                this.attackCooldown = 500; // en millisecondes
                this.attackDamage = 1;
            }
            
            update() {
                if (this.moving) {
                    this.frameTimer++;
                    if (this.frameTimer >= this.frameDuration) {
                        this.frameTimer = 0;
                        this.frame = (this.frame + 1) % this.frameCount;
                    }
                } else {
                    this.frame = 0; // Frame statique quand immobile
                }
            }
            
            draw(ctx, camera, isPlayer = true) {
                // Convertir les coordonnées cartésiennes en isométriques
                const iso = cartToIso(this.x - camera.x, this.y - camera.y);
                const screenX = iso.x + ctx.canvas.width / 2;
                const screenY = iso.y + 100; // Décalage pour centrer verticalement
                
                // Dessiner le sprite
                if (isPlayer) {
                    this.drawPlayer(ctx, screenX, screenY);
                } else {
                    this.drawMonster(ctx, screenX, screenY);
                }
                
                // Dessiner la barre de vie
                this.drawHealthBar(ctx, screenX, screenY);
                
                // DEBUG: Dessiner le cercle de portée d'attaque pour le joueur
                if (isPlayer) {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.beginPath();
                    
                    // Convertir le rayon de portée en isométrique (approximation)
                    const attackRangeIso = this.attackRange * 0.7; // Ajustement pour l'isométrie
                    
                    ctx.ellipse(screenX, screenY, attackRangeIso, attackRangeIso/2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            drawPlayer(ctx, screenX, screenY) {
                // Calculer l'index du frame dans la feuille de sprites
                const directionRow = this.directionMap[this.direction];
                const frameIndex = directionRow * 6 + this.frame;
                
                // Essayer d'utiliser la spritesheet
                if (this.spriteManager && this.spriteManager.spritesheets['player']) {
                    this.spriteManager.drawSpriteFrame(
                        ctx, 
                        'player', 
                        frameIndex, 
                        screenX, 
                        screenY, 
                        this.width, 
                        this.height
                    );
                } else {
                    // Fallback: dessiner un cercle bleu
                    ctx.fillStyle = '#3498DB';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Indiquer la direction
                    ctx.fillStyle = '#ffffff';
                    const dirX = screenX + Math.cos(this.getDirectionAngle()) * (this.width / 3);
                    const dirY = screenY + Math.sin(this.getDirectionAngle()) * (this.width / 3);
                    ctx.beginPath();
                    ctx.arc(dirX, dirY, this.width / 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            drawMonster(ctx, screenX, screenY) {
                // Pour les monstres (slimes)
                const frameIndex = this.frame;
                
                // Essayer d'utiliser la spritesheet
                if (this.spriteManager && this.spriteManager.spritesheets['slime']) {
                    this.spriteManager.drawSpriteFrame(
                        ctx, 
                        'slime', 
                        frameIndex, 
                        screenX, 
                        screenY, 
                        this.width, 
                        this.height
                    );
                } else {
                    // Fallback: dessiner un carré rouge
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillRect(
                        screenX - this.width / 2,
                        screenY - this.height / 2,
                        this.width,
                        this.height
                    );
                }
            }
            
            drawHealthBar(ctx, screenX, screenY) {
                const healthBarWidth = this.width;
                const healthBarHeight = 4;
                const healthPercent = Math.max(0, this.health) / this.maxHealth;
                
                // Fond de la barre de vie
                ctx.fillStyle = '#555';
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY - this.height / 2 - 10,
                    healthBarWidth,
                    healthBarHeight
                );
                
                // Barre de vie
                ctx.fillStyle = healthPercent > 0.5 ? '#2ECC71' : healthPercent > 0.25 ? '#F39C12' : '#E74C3C';
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY - this.height / 2 - 10,
                    healthBarWidth * healthPercent,
                    healthBarHeight
                );
            }
            
            // Convertir la direction en angle (en radians)
            getDirectionAngle() {
                switch(this.direction) {
                    case 'up': return -Math.PI / 2;
                    case 'right': return 0;
                    case 'down': return Math.PI / 2;
                    case 'left': return Math.PI;
                    default: return 0;
                }
            }
            
            // Vérifier si un monstre est à portée d'attaque
            canAttack(monster) {
                const dx = monster.x - this.x;
                const dy = monster.y - this.y;
                const dist = Math.hypot(dx, dy);
                return dist <= this.attackRange;
            }
            
            // Attaque automatique vers le monstre le plus proche
            autoAttack(monsters, game) {
                // Vérifier le cooldown d'attaque
                const now = performance.now();
                if (now - this.lastAttackTime < this.attackCooldown) {
                    return null; // Attaque en cooldown
                }
                
                // Trouver le monstre le plus proche
                let closestMonster = null;
                let closestDistance = Infinity;
                
                for (const monster of monsters) {
                    const dx = monster.x - this.x;
                    const dy = monster.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < closestDistance && dist <= this.attackRange) {
                        closestMonster = monster;
                        closestDistance = dist;
                    }
                }
                
                // Si un monstre est à portée, attaquer
                if (closestMonster) {
                    // Mettre à jour le cooldown
                    this.lastAttackTime = now;
                    
                    // Calculer la direction vers le monstre
                    const dx = closestMonster.x - this.x;
                    const dy = closestMonster.y - this.y;
                    
                    // Normaliser le vecteur direction
                    const dist = Math.hypot(dx, dy);
                    const dirX = dx / dist;
                    const dirY = dy / dist;
                    
                    // Mettre à jour la direction du joueur
                    if (Math.abs(dirX) > Math.abs(dirY)) {
                        this.direction = dirX > 0 ? 'right' : 'left';
                    } else {
                        this.direction = dirY > 0 ? 'down' : 'up';
                    }
                    
                    // Créer un projectile vers le monstre
                    return new Projectile(
                        this.x,
                        this.y,
                        dirX,
                        dirY,
                        400, // Vitesse
                        this.attackDamage // Dégâts
                    );
                }
                
                return null; // Pas de monstre à portée
            }
        }

        // 3. Classe pour les projectiles
        class Projectile {
            constructor(x, y, dirX, dirY, speed, damage) {
                this.x = x;
                this.y = y;
                this.dirX = dirX;
                this.dirY = dirY;
                this.speed = speed;
                this.damage = damage;
                this.radius = 4;
            }
            
            update(deltaTime) {
                this.x += this.dirX * this.speed * deltaTime;
                this.y += this.dirY * this.speed * deltaTime;
            }
            
            draw(ctx, camera) {
                // Convertir les coordonnées cartésiennes en isométriques
                const iso = cartToIso(this.x - camera.x, this.y - camera.y);
                const screenX = iso.x + ctx.canvas.width / 2;
                const screenY = iso.y + 100;
                
                ctx.fillStyle = '#3498DB';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Vérifier la collision avec une entité (joueur ou monstre)
            checkCollision(entity) {
                const dist = Math.hypot(this.x - entity.x, this.y - entity.y);
                return dist < this.radius + entity.width / 2;
            }
        }

        // 4. Classe TileMap pour la carte du jeu en isométrique
        class IsometricTileMap {
            constructor(width, height, tileSize, spriteManager) {
                this.width = width;
                this.height = height;
                this.tileSize = tileSize;
                this.tiles = [];
                this.spriteManager = spriteManager;
                
                // Initialiser la carte avec des tuiles vides
                for (let y = 0; y < height; y++) {
                    this.tiles[y] = [];
                    for (let x = 0; x < width; x++) {
                        this.tiles[y][x] = 0; // 0 = tuile vide
                    }
                }
            }
            
            // Définir une tuile à une position spécifique
            setTile(x, y, tileType) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    this.tiles[y][x] = tileType;
                }
            }
            
            // Obtenir le type de tuile à une position
            getTile(x, y) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    return this.tiles[y][x];
                }
                return -1; // En dehors de la carte
            }
            
            // Vérifier si une tuile est un obstacle
            isTileObstacle(tileType) {
                // Dans cet exemple, aucune tuile n'est un obstacle
                // Vous pourriez modifier ça selon vos besoins
                return false;
            }
            
            // Vérifier si une position est un obstacle
            isObstacle(worldX, worldY) {
                const tileX = Math.floor(worldX / this.tileSize);
                const tileY = Math.floor(worldY / this.tileSize);
                const tileType = this.getTile(tileX, tileY);
                
                return this.isTileObstacle(tileType);
            }
            
            // Générer la carte isométrique depuis la configuration
            generateMapFromConfig(config) {
    // Déterminer les indices des tuiles
    const tileIndices = {
        'iso_dirt': 1,
        'iso_stone': 2,
        'iso_dry': 3
    };
    
    // Remplir avec la tuile de base
    const baseTileIndex = tileIndices[config.tiles.base] || 1;
    for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
            this.tiles[y][x] = baseTileIndex;
        }
    }
    
    // Ajouter les zones spéciales
    if (config.tiles.special) {
        for (const special of config.tiles.special) {
            const tileIndex = tileIndices[special.tile] || 1;
            
            if (special.type === 'zone') {
                const centerX = Math.floor(special.centerX * this.width);
                const centerY = Math.floor(special.centerY * this.height);
                const radius = Math.floor(special.radius * Math.min(this.width, this.height));
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < radius) {
                            this.tiles[y][x] = tileIndex;
                        }
                    }
                }
            }
            else if (special.type === 'random') {
                for (let i = 0; i < special.count; i++) {
                    const zoneX = Math.floor(Math.random() * this.width);
                    const zoneY = Math.floor(Math.random() * this.height);
                    const zoneRadius = special.radius || 3;
                    
                    for (let y = 0; y < this.height; y++) {
                        for (let x = 0; x < this.width; x++) {
                            const dx = x - zoneX;
                            const dy = y - zoneY;
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            
                            if (distance < zoneRadius) {
                                this.tiles[y][x] = tileIndex;
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Ajouter les obstacles (à implémenter si nécessaire)
    // ...
}
            
            // Dessiner la carte isométrique
            draw(ctx, camera) {
                // L'ordre de dessin est important en isométrique!
                // Nous parcourons de haut en bas et de gauche à droite
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tileType = this.tiles[y][x];
                        
                        // Calculer les coordonnées du monde cartésien
                        const worldX = x * this.tileSize;
                        const worldY = y * this.tileSize;
                        
                        // Convertir en coordonnées isométriques
                        const iso = cartToIso(worldX - camera.x, worldY - camera.y);
                        
                        // Coordonnées à l'écran (centrage)
                        const screenX = iso.x + ctx.canvas.width / 2;
                        const screenY = iso.y + 100; // Offset pour centrer verticalement
                        
                        // Dessiner la tuile
                        this.drawTile(ctx, screenX, screenY, tileType);
                    }
                }
            }
            
            // Dessiner une tuile spécifique
            drawTile(ctx, screenX, screenY, tileType) {
                // Choisir la bonne image selon le type de tuile
                let tileImage;
                
                switch(tileType) {
                    case 1:
                        tileImage = this.spriteManager.getSprite('iso_dirt');
                        break;
                    case 2:
                        tileImage = this.spriteManager.getSprite('iso_stone');
                        break;
                    case 3:
                        tileImage = this.spriteManager.getSprite('iso_dry');
                        break;
                    default:
                        return; // Ne rien dessiner pour les tuiles vides
                }
                
                if (tileImage) {
                    // Dessiner l'image de la tuile
                    ctx.drawImage(
                        tileImage,
                        screenX - tileImage.width/2,  // Centrer l'image en X
                        screenY - tileImage.height/2, // Centrer l'image en Y
                        tileImage.width,
                        tileImage.height
                    );
                } else {
                    // Fallback: dessiner un losange coloré
                    const tileWidth = this.tileSize * 2;  // Plus large que haute en isométrie
                    const tileHeight = this.tileSize;
                    
                    let color;
                    switch(tileType) {
                        case 1: color = '#8B4513'; break; // Marron pour la terre
                        case 2: color = '#A9A9A9'; break; // Gris pour la pierre
                        case 3: color = '#D2B48C'; break; // Beige pour la terre sèche
                        default: color = '#FF00FF'; break;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - tileHeight/2);            // Haut
                    ctx.lineTo(screenX + tileWidth/2, screenY);             // Droite
                    ctx.lineTo(screenX, screenY + tileHeight/2);            // Bas
                    ctx.lineTo(screenX - tileWidth/2, screenY);             // Gauche
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.stroke();
                }
            }
        }

        // 5. Classe Game principale
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Redimensionner le canvas pour correspondre à la taille de la fenêtre
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Gestionnaire de sprites
                this.spriteManager = new SpriteManager();
                
                // Paramètres du jeu
                this.tileSize = 64;
                this.mapWidth = 20;
                this.mapHeight = 20;
                
                // Carte
                this.tileMap = new IsometricTileMap(this.mapWidth, this.mapHeight, this.tileSize, this.spriteManager);
                
                // Joueur
                this.player = new AnimatedCharacter(
                    this.spriteManager,
                    this.mapWidth * this.tileSize / 2,
                    this.mapHeight * this.tileSize / 2,
                    this.tileSize,
                    this.tileSize * 1.5
                );
                
                // Monstres
                this.monsters = [];
                
                // Projectiles
                this.projectiles = [];
                
                // Caméra
                this.camera = {
                    x: this.player.x - this.canvas.width / 2,
                    y: this.player.y - this.canvas.height / 2
                };
                
                // Etat du jeu
                this.gameOver = false;
                this.score = 0;
                this.wave = 1;
                this.gameTime = 0;
                
                // Contrôles clavier
                this.keys = {
                    ArrowUp: false,
                    ArrowDown: false,
                    ArrowLeft: false,
                    ArrowRight: false,
                    ' ': false // Espace pour tirer
                };
                
                // Timing
                this.lastTime = 0;
                this.delta = 0;
                
                // Etat de chargement
                this.loading = true;

                // Nouvelle propriété pour la limite de vagues et le suivi
                this.maxWaves = 3;
                this.currentWave = 1;
                this.wavesCompleted = 0;
                this.totalWaves = 0;            // Compteur pour toutes les vagues générées (pour la difficulté)
                this.gameCompleted = false; // pour distinguer de gameOver (défaite)
                
                // Pour éviter les envois multiples de score
                this.scoreSubmitted = false;
                
                // Initialiser les écouteurs d'événements
                this.setupEventListeners();
                
                // Charger les ressources et démarrer le jeu
                this.init();
            }
            
            generateMap() {
                if (this.levelConfig) {
                    this.tileMap.generateMapFromConfig(this.levelConfig);
                } else {
                    this.tileMap.generateIsometricMap(); // Méthode de secours
                }
            }

            drawStar(x, y, size, isActive) {
                this.ctx.save();
                
                // Couleur selon l'état (actif ou non)
                if (isActive) {
                    // Étoile brillante
                    this.ctx.fillStyle = '#FFD700'; // Or
                    this.ctx.shadowColor = '#FFD700';
                    this.ctx.shadowBlur = 15;
                } else {
                    // Étoile éteinte
                    this.ctx.fillStyle = '#555555';
                }
                
                // Dessiner l'étoile
                this.ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                    const outerX = x + size/2 * Math.cos(angle);
                    const outerY = y + size/2 * Math.sin(angle);
                    
                    if (i === 0) {
                        this.ctx.moveTo(outerX, outerY);
                    } else {
                        this.ctx.lineTo(outerX, outerY);
                    }
                    
                    // Point intérieur
                    const innerAngle = angle + Math.PI / 5;
                    const innerX = x + size/5 * Math.cos(innerAngle);
                    const innerY = y + size/5 * Math.sin(innerAngle);
                    this.ctx.lineTo(innerX, innerY);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.restore();
            }

            drawButton(text, x, y, width, height, color, textColor, onClick) {
                // Dessiner le bouton
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.roundRect(x - width/2, y - height/2, width, height, 8);
                this.ctx.fill();
                
                // Texte du bouton
                this.ctx.fillStyle = textColor;
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text, x, y);
                
                // Ajouter l'événement de clic si l'écouteur n'existe pas déjà
                if (!this.buttonClickListener) {
                    this.buttonClickListener = (event) => {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = event.clientX - rect.left;
                        const mouseY = event.clientY - rect.top;
                        
                        // Vérifier si le clic est sur le bouton
                        if (mouseX >= x - width/2 && mouseX <= x + width/2 &&
                            mouseY >= y - height/2 && mouseY <= y + height/2) {
                            onClick();
                        }
                    };
                    
                    this.canvas.addEventListener('click', this.buttonClickListener);
                }
            }

            handleReturnToMenu() {
                // Nettoyer les écouteurs d'événements avant de quitter
                if (this.buttonClickListener) {
                    this.canvas.removeEventListener('click', this.buttonClickListener);
                    this.buttonClickListener = null;
                }
                
                // Rediriger vers la page principale
                window.location.href = '/battle.html';
            }

            submitResults() {
                const token = localStorage.getItem('token');
                if (!token) return;
                
                // Récupérer l'ID du niveau depuis l'URL
                const urlParams = new URLSearchParams(window.location.search);
                const levelId = parseInt(urlParams.get('level') || '1');
                
                // Préparer les données à envoyer
                const data = {
                    levelId: levelId,
                    success: this.gameCompleted,
                    score: this.score,
                    starsCount: this.getStarsCount(),
                    timeSpent: Math.floor(this.gameTime)
                };
                
                // Envoyer les résultats au serveur
                fetchWithAuth('/api/battle/complete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                })
                .then(res => {
                    if (!res.ok) {
                        throw new Error('Erreur lors de l\'envoi des résultats');
                    }
                    return res.json();
                })
                .then(response => {
                    console.log('Résultats envoyés avec succès:', response);
                    
                    // Note: pas besoin d'alerte ici, l'écran de fin est suffisant
                })
                .catch(error => {
                    console.error('Erreur:', error);
                });
            }

            async init() {
            try {
                // Vérifier l'authentification
                if (!localStorage.getItem('token')) {
                    alert('Veuillez vous connecter pour jouer');
                    window.location.href = '/';
                    return;
                }
                
                // Charger les statistiques du joueur
                await this.loadPlayerStats();
                
                // Charger le niveau sélectionné
                await this.loadLevelConfig();
                
                // Charger les sprites
                await this.loadSprites();
                
                // Générer la carte basée sur la configuration du niveau
                this.generateMap();
                
                // Spawner les monstres basés sur la configuration du niveau
                this.spawnInitialMonsters();
                
                // Fin du chargement
                this.loading = false;
                
                // Démarrer la boucle de jeu
                this.lastTime = performance.now();
                requestAnimationFrame(this.gameLoop.bind(this));
            } catch (error) {
                console.error("Erreur lors de l'initialisation:", error);
            }
        }

        async loadLevelConfig() {
    try {
        // Récupérer l'ID du niveau depuis l'URL
        const urlParams = new URLSearchParams(window.location.search);
        this.levelId = parseInt(urlParams.get('level') || '1');
        
        // Charger le fichier de configuration
        const response = await fetch('/configs/levels.json');
        if (!response.ok) {
            throw new Error('Erreur lors du chargement de la configuration des niveaux');
        }
        
        const config = await response.json();
        
        // Trouver le niveau correspondant
        this.levelConfig = config.levels.find(level => level.id === this.levelId);
        
        if (!this.levelConfig) {
            throw new Error(`Niveau ${this.levelId} non trouvé`);
        }
        
        console.log("Configuration du niveau chargée:", this.levelConfig);
    } catch (error) {
        console.error("Erreur lors du chargement du niveau:", error);
        // Configuration par défaut en cas d'erreur
        this.levelConfig = {
            id: 1,
            name: "Niveau par défaut",
            description: "Niveau de secours",
            tiles: {
                base: "iso_dirt",
                special: []
            },
            monsters: [
                {
                    type: "slime",
                    count: 10,
                    health: 3,
                    speed: 50,
                    damage: 1
                }
            ],
            obstacles: []
        };
    }
}
        // Nouvelle méthode pour charger les statistiques du joueur
        async loadPlayerStats() {
            try {
                const response = await fetchWithAuth('/api/player/stats');
                
                if (!response.ok) {
                    throw new Error('Erreur lors du chargement des statistiques');
                }
                
                const stats = await response.json();
                
                // Appliquer les statistiques au joueur
                this.player.attackDamage = 1+ stats.attack*stats.attack/5 ;
                this.player.attackRange = 200 + stats.range*4 ;
                this.player.speed = stats.speed*2 + 100;
                this.player.maxHealth = stats.health*stats.health/2 + 10;
                this.player.health = this.player.maxHealth;
                
                // Calculer d'autres statistiques dérivées
                this.player.attackCooldown = 500 / (1 + stats.precision * 0.1);
                
                console.log("Statistiques du joueur chargées:", stats);
            } catch (error) {
                console.error("Erreur lors du chargement des statistiques:", error);
                // Utiliser des valeurs par défaut
                this.player.attackDamage = 1;
                this.player.attackRange = 200;
                this.player.speed = 200;
                this.player.maxHealth = 10;
                this.player.health = 10;
                this.player.attackCooldown = 500;
            }
        }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            setupEventListeners() {
                // Contrôles clavier
                window.addEventListener('keydown', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = true;
                        
                        // Empêcher le défilement de la page avec les flèches
                        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                            e.preventDefault();
                        }
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = false;
                    }
                    
                    // Redémarrer le jeu quand on appuie sur Espace après un Game Over
                    if (this.gameOver && e.key === ' ') {
                        this.restart();
                    }
                });
            }
            
            async loadSprites() {
                // Liste des sprites à charger
                const spritesList = {
                    'player': '/assets/images/player.png',      // Sprite du joueur
                    'slime': '/assets/images/slime.png',        // Sprite du slime
                    'iso_dirt': '/assets/images/iso_dirt.png',  // Première tuile isométrique (terre)
                    'iso_stone': '/assets/images/iso_stone.png', // Deuxième tuile isométrique (pierre)
                    'iso_dry': '/assets/images/iso_dry.png'     // Troisième tuile isométrique (terre sèche)
                };
                
                try {
                    // Tenter de charger les sprites
                    await this.spriteManager.loadSprites(spritesList);
                    
                    // Configurer les spritesheets
                    this.spriteManager.spritesheets['player'] = {
                        image: this.spriteManager.sprites['player'],
                        frameWidth: 48,
                        frameHeight: 48,
                        framesPerRow: 6,
                        rows: 4
                    };
                    
                    this.spriteManager.spritesheets['slime'] = {
                        image: this.spriteManager.sprites['slime'],
                        frameWidth: 32,
                        frameHeight: 32,
                        framesPerRow: 7,
                        rows: 4
                    };
                    
                    console.log("Sprites chargés avec succès!");
                    
                } catch (error) {
                    console.error("Erreur lors du chargement des sprites:", error);
                    // Continuer sans sprites
                }
            }
            
            spawnInitialMonsters() {
            if (!this.levelConfig || !this.levelConfig.monsters) {
                return;
            }
            
            for (const monsterConfig of this.levelConfig.monsters) {
                for (let i = 0; i < monsterConfig.count; i++) {
                    // Calculer la position aléatoire éloignée du joueur
                    let x, y;
                    do {
                        x = Math.random() * this.mapWidth * this.tileSize;
                        y = Math.random() * this.mapHeight * this.tileSize;
                    } while (
                        Math.hypot(x - this.player.x, y - this.player.y) < 300 ||
                        this.tileMap.isObstacle(x, y)
                    );
                    
                    // Créer le monstre
                    const monster = new AnimatedCharacter(
                        this.spriteManager,
                        x,
                        y,
                        this.tileSize,
                        this.tileSize
                    );
                    
                    // Configurer le monstre selon la configuration
                    monster.monsterType = monsterConfig.type;
                    monster.speed = monsterConfig.speed;
                    monster.health = monsterConfig.health * (1 + this.wave * 0.2);
                    monster.maxHealth = monster.health;
                    monster.damage = monsterConfig.damage * (1 + this.wave * 0.1);
                    
                    this.monsters.push(monster);
                }
            }
        }
            
            gameLoop(timestamp) {
                // Calculer le delta time
                this.delta = (timestamp - this.lastTime) / 1000; // en secondes
                this.lastTime = timestamp;
                this.gameTime += this.delta;
                
                // Limiter le delta time pour éviter les comportements étranges
                if (this.delta > 0.1) this.delta = 0.1;
                
                // Mettre à jour et dessiner selon l'état du jeu
                if (this.loading) {
                    this.renderLoadingScreen();
                } else if (this.gameOver || this.gameCompleted) {
                    this.update(this.delta);
                    this.render();
                    this.renderGameEndScreen();
                } else {
                    this.update(this.delta);
                    this.render();
                }
                
                // Continuer la boucle de jeu
                requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            update(deltaTime) {
                // Mise à jour du joueur
                this.updatePlayer(deltaTime);
                
                // Mise à jour des monstres
                this.updateMonsters(deltaTime);
                
                // Vérifier les attaques automatiques
                this.checkAutoAttacks();
                
                // Mise à jour des projectiles
                this.updateProjectiles(deltaTime);
                
                // Mise à jour de la caméra
                this.updateCamera();
                
                // Vérifier si la vague est terminée
                if (this.monsters.length === 0 && !this.gameCompleted && !this.gameOver) {
                    // Incrémenter le compteur de vagues terminées
                    this.wavesCompleted = this.currentWave;
                    
                    // Vérifier si toutes les vagues sont terminées
                    if (this.currentWave >= this.maxWaves) {
                        // Victoire ! Le joueur a terminé les 3 vagues
                        console.log("Toutes les vagues terminées! Victoire!");
                        this.gameCompleted = true;
                        return; // Ne pas générer plus de monstres
                    }
                    
                    // Passer à la vague suivante
                    this.currentWave++;
                    this.totalWaves++;
                    
                    console.log(`Passage à la vague ${this.currentWave}/${this.maxWaves}`);
                    
                    // Générer la nouvelle vague avec difficulté croissante
                    this.spawnInitialMonsters();
                }
            }
            getStarsCount() {
                return this.wavesCompleted; // 0-3 étoiles
            }

            updatePlayer(deltaTime) {
                // Déplacement du joueur
                const playerSpeed = 200 * deltaTime;
                let dx = 0;
                let dy = 0;
                
                // En isométrique, les contrôles sont un peu différents pour que le mouvement
                // semble naturel dans la vue en losange
                if (this.keys.ArrowUp) {
                    dx -= playerSpeed;
                    dy -= playerSpeed;
                    this.player.direction = 'up';
                }
                if (this.keys.ArrowDown) {
                    dx += playerSpeed;
                    dy += playerSpeed;
                    this.player.direction = 'down';
                }
                if (this.keys.ArrowLeft) {
                    dx -= playerSpeed;
                    dy += playerSpeed;
                    this.player.direction = 'left';
                }
                if (this.keys.ArrowRight) {
                    dx += playerSpeed;
                    dy -= playerSpeed;
                    this.player.direction = 'right';
                }
                
                // Vérifier les collisions avec les obstacles
                // En diagonale, on vérifie les deux axes séparément pour permettre
                // de glisser le long des obstacles
                if (dx !== 0) {
                    const newX = this.player.x + dx;
                    if (!this.tileMap.isObstacle(newX, this.player.y)) {
                        this.player.x = newX;
                    }
                }
                
                if (dy !== 0) {
                    const newY = this.player.y + dy;
                    if (!this.tileMap.isObstacle(this.player.x, newY)) {
                        this.player.y = newY;
                    }
                }
                
                // Mettre à jour l'état de mouvement
                this.player.moving = dx !== 0 || dy !== 0;
                
                // Mettre à jour l'animation
                this.player.update();
            }
            
            updateMonsters(deltaTime) {
                for (let i = this.monsters.length - 1; i >= 0; i--) {
                    const monster = this.monsters[i];
                    
                    // Calculer la direction vers le joueur
                    const dx = this.player.x - monster.x;
                    const dy = this.player.y - monster.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 0) {
                        // Normaliser les vecteurs de direction
                        const dirX = dx / dist;
                        const dirY = dy / dist;
                        
                        // Déplacer le monstre
                        const speed = monster.speed * deltaTime;
                        
                        // Vérifier les collisions avec les obstacles (déplacement sur X)
                        const newX = monster.x + dirX * speed;
                        if (!this.tileMap.isObstacle(newX, monster.y)) {
                            monster.x = newX;
                        }
                        
                        // Vérifier les collisions avec les obstacles (déplacement sur Y)
                        const newY = monster.y + dirY * speed;
                        if (!this.tileMap.isObstacle(monster.x, newY)) {
                            monster.y = newY;
                        }
                        
                        // Déterminer la direction pour l'animation
                        if (Math.abs(dirX) > Math.abs(dirY)) {
                            monster.direction = dirX > 0 ? 'right' : 'left';
                        } else {
                            monster.direction = dirY > 0 ? 'down' : 'up';
                        }
                        
                        monster.moving = true;
                    } else {
                        monster.moving = false;
                    }
                    
                    // Mettre à jour l'animation
                    monster.update();
                    
                    // Vérifier la collision avec le joueur
                    if (dist < (this.player.width + monster.width) / 3) {
                        // Le joueur perd de la vie
                        this.player.health -= monster.damage * deltaTime;
                        
                        // Game over si le joueur n'a plus de vie
                        if (this.player.health <= 0) {
                            this.player.health = 0;
                            this.gameOver = true;
                        }
                    }
                }
            }
            
            // Vérifier si le joueur peut attaquer automatiquement
            checkAutoAttacks() {
                const projectile = this.player.autoAttack(this.monsters, this);
                if (projectile) {
                    this.projectiles.push(projectile);
                }
            }
            
            updateProjectiles(deltaTime) {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    // Mettre à jour la position
                    proj.update(deltaTime);
                    
                    // Vérifier la collision avec les obstacles
                    if (this.tileMap.isObstacle(proj.x, proj.y)) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Vérifier la collision avec les monstres
                    let hitMonster = false;
                    
                    for (let j = this.monsters.length - 1; j >= 0; j--) {
                        const monster = this.monsters[j];
                        
                        if (proj.checkCollision(monster)) {
                            // Infliger des dégâts au monstre
                            monster.health -= proj.damage;
                            
                            // Vérifier si le monstre est mort
                            if (monster.health <= 0) {
                                this.monsters.splice(j, 1);
                                this.score += 10; // Augmenter le score
                            }
                            
                            hitMonster = true;
                            break;
                        }
                    }
                    
                    // Supprimer le projectile s'il a touché un monstre
                    if (hitMonster) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Supprimer le projectile s'il est hors de la carte
                    if (
                        proj.x < 0 || proj.x > this.mapWidth * this.tileSize ||
                        proj.y < 0 || proj.y > this.mapHeight * this.tileSize
                    ) {
                        this.projectiles.splice(i, 1);
                    }
                }
            }
            
            updateCamera() {
                // La caméra suit le joueur avec un léger délai
                const targetX = this.player.x - this.canvas.width / 2;
                const targetY = this.player.y - this.canvas.height / 2;
                
                this.camera.x += (targetX - this.camera.x) * 0.1;
                this.camera.y += (targetY - this.camera.y) * 0.1;
                
                // Limiter la caméra aux bords de la carte
                const maxX = this.mapWidth * this.tileSize - this.canvas.width;
                const maxY = this.mapHeight * this.tileSize - this.canvas.height;
                
                this.camera.x = Math.max(0, Math.min(this.camera.x, maxX));
                this.camera.y = Math.max(0, Math.min(this.camera.y, maxY));
            }
            
            render() {
                // Effacer le canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Dessiner la carte
                this.tileMap.draw(this.ctx, this.camera);
                
                // Trier tous les éléments mobiles par leur position Y pour un rendu isométrique correct
                const entities = [...this.monsters, this.player, ...this.projectiles];
                entities.sort((a, b) => a.y - b.y);
                
                // Dessiner les entités dans l'ordre de profondeur
                for (const entity of entities) {
                    if (entity === this.player) {
                        entity.draw(this.ctx, this.camera, true);
                    } else if (this.monsters.includes(entity)) {
                        entity.draw(this.ctx, this.camera, false);
                    } else {
                        entity.draw(this.ctx, this.camera);
                    }
                }
                
                // Dessiner l'UI
                this.renderUI();
            }
            
            renderUI() {
                // Score et vague
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                this.ctx.fillText(`Vague: ${this.wave}`, 20, 60);
                this.ctx.fillText(`Monstres: ${this.monsters.length}`, 20, 90);
                
                // Barre de vie du joueur
                const healthBarWidth = 200;
                const healthBarHeight = 20;
                const healthPercent = Math.max(0, this.player.health) / this.player.maxHealth;
                
                // Fond de la barre
                this.ctx.fillStyle = '#333333';
                this.ctx.fillRect(
                    this.canvas.width - healthBarWidth - 20,
                    20,
                    healthBarWidth,
                    healthBarHeight
                );
                
                // Barre de vie
                this.ctx.fillStyle = healthPercent > 0.5 ? '#2ECC71' : healthPercent > 0.25 ? '#F39C12' : '#E74C3C';
                this.ctx.fillRect(
                    this.canvas.width - healthBarWidth - 20,
                    20,
                    healthBarWidth * healthPercent,
                    healthBarHeight
                );
                
                // Texte de la barre de vie
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    `PV: ${Math.ceil(this.player.health)}/${this.player.maxHealth}`,
                    this.canvas.width - healthBarWidth / 2 - 20,
                    20 + healthBarHeight / 2 + 6
                );
                
                // Instructions de jeu
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    'Flèches pour se déplacer | Attaque automatique quand les monstres sont à portée',
                    this.canvas.width / 2,
                    this.canvas.height - 20
                );
            }
            
            renderLoadingScreen() {
                // Effacer le canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Fond
                this.ctx.fillStyle = '#111111';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Titre
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '36px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Chargement...', this.canvas.width / 2, this.canvas.height / 2 - 50);
                
                // Barre de progression
                const progressWidth = this.canvas.width * 0.6;
                const progressHeight = 20;
                const progress = this.spriteManager.getLoadingProgress();
                
                // Fond de la barre
                this.ctx.fillStyle = '#333333';
                this.ctx.fillRect(
                    (this.canvas.width - progressWidth) / 2,
                    this.canvas.height / 2,
                    progressWidth,
                    progressHeight
                );
                
                // Barre de progression
                this.ctx.fillStyle = '#3498DB';
                this.ctx.fillRect(
                    (this.canvas.width - progressWidth) / 2,
                    this.canvas.height / 2,
                    progressWidth * (progress / 100),
                    progressHeight
                );
                
                // Texte de progression
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '16px Arial';
                this.ctx.fillText(
                    `${progress}%`,
                    this.canvas.width / 2,
                    this.canvas.height / 2 + 40
                );
            }
            
            renderGameEndScreen() {
                // Semi-transparent overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Titre selon l'état
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                
                if (this.gameCompleted) {
                    this.ctx.fillStyle = '#4CAF50'; // Vert pour victoire
                    this.ctx.fillText('VICTOIRE !', this.canvas.width / 2, this.canvas.height / 3 - 20);
                } else {
                    this.ctx.fillStyle = '#F44336'; // Rouge pour défaite
                    this.ctx.fillText('DÉFAITE', this.canvas.width / 2, this.canvas.height / 3 - 20);
                }
                
                // Dessiner les étoiles
                const starsCount = this.getStarsCount();
                const starSize = 60;
                const starsWidth = 3 * starSize * 1.5; // Espace entre les étoiles (1.5x)
                const startX = (this.canvas.width - starsWidth) / 2 + starSize/2;
                const startY = this.canvas.height / 3 + 50;
                
                for (let i = 0; i < 3; i++) {
                    const starX = startX + i * starSize * 1.5;
                    const isActive = i < starsCount;
                    this.drawStar(starX, startY, starSize, isActive);
                }
                
                // Score
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(`Score final: ${this.score}`, this.canvas.width / 2, startY + starSize + 40);
                
                // Vagues complétées
                this.ctx.font = '20px Arial';
                this.ctx.fillText(`Vagues complétées: ${this.wavesCompleted} / ${this.maxWaves}`, this.canvas.width / 2, startY + starSize + 80);
                
                // Bouton de retour au menu
                this.drawButton(
                    'RETOUR AU MENU', 
                    this.canvas.width / 2, 
                    this.canvas.height * 3/4,
                    220, 60, 
                    '#3f51b5', 
                    '#ffffff',
                    this.handleReturnToMenu.bind(this)
                );
                
                // Soumettre le score et les progrès (seulement une fois)
                if (!this.scoreSubmitted) {
                    this.submitResults();
                    this.scoreSubmitted = true;
                }
            }
            
            restart() {
                // Réinitialiser le jeu
                this.player.x = this.mapWidth * this.tileSize / 2;
                this.player.y = this.mapHeight * this.tileSize / 2;
                this.player.health = this.player.maxHealth;
                
                this.monsters = [];
                this.projectiles = [];
                this.score = 0;
                this.wave = 1;
                this.gameOver = false;
                
                // Spawner les premiers monstres
                this.spawnInitialMonsters();
            }
        }

        // Démarrer le jeu lorsque la page est chargée
        window.onload = function() {
            if (!checkAuth()) return;
            const canvas = document.getElementById('gameCanvas');
            const game = new Game(canvas);
        };
    </script>
</body>
</html>